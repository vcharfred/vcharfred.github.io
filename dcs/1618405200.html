<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="keywords" content="Elasticsearch,es,分布式搜索, 起岸星辰">
    <meta name="description" content="Elasticsearch是实时全文搜索和分析引擎，提供搜集、分析、存储数据三大功能；是一套开放REST和JAVA API等结构提供高效搜索功能，可扩展的分布式系统。它构建于Apache Lucene搜索引擎库之上。">
    <meta property="og:type" content="article"/>
    <meta property="og:title" content="Elasticsearch7学习笔记(上) | 起岸星辰"/>
    <meta property="og:description" content="Elasticsearch是实时全文搜索和分析引擎，提供搜集、分析、存储数据三大功能；是一套开放REST和JAVA API等结构提供高效搜索功能，可扩展的分布式系统。它构建于Apache Lucene搜索引擎库之上。"/>
    <meta property="og:site_name" content="起岸星辰">
    <meta property="og:url" content="https://blog.vchar.top/dcs/1618405200.html"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="baidu-site-verification" content="code-IA8XRSu9fC" />
    <meta name="360-site-verification" content="14ea430e0b22dd11ff0593fdeb96537b" />
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Elasticsearch7学习笔记(上) | 起岸星辰</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="https://lib.baomitu.com/materialize/1.0.0/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.min.css">
<!--     <style> html {filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);-webkit-filter: grayscale(100%);} </style> -->
    <!-- 百度统计 -->
    <script>var _hmt = _hmt || [];(function () {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?3ce1a891c034d9ea1ca5da217345bb0c";var s = document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm, s);})();</script>
    <script src="https://lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script>
<meta name="generator" content="Hexo 5.3.0"></head>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">起岸星辰</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">起岸星辰</div>
        <div class="logo-desc">
            
            起岸星辰
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/27.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Elasticsearch7学习笔记(上)</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Elasticsearch/">
                                <span class="chip bg-color">Elasticsearch</span>
                            </a>
                        
                            <a href="/tags/es/">
                                <span class="chip bg-color">es</span>
                            </a>
                        
                            <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/">
                                <span class="chip bg-color">分布式搜索</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/" class="post-category">
                                分布式搜索
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-04-14
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>Elasticsearch是实时全文搜索和分析引擎，提供搜集、分析、存储数据三大功能；是一套开放REST和JAVA API等结构提供高效搜索功能，可扩展的分布式系统。它构建于Apache Lucene搜索引擎库之上。</p>
<blockquote>
<p>本文是在学习 中华石杉老师的 Elasticsearch顶尖高手系列 的视频教程的过程中做的笔记，实际操作使用的Elasticsearch7而非视频教程中使用的版本；现在这套视频教程是免费公开的（网上直接搜索就有），强烈推荐大家去观看学习。</p>
</blockquote>
<ul>
<li><a href="/dcs/1618405200.html">Elasticsearch7学习笔记(上)</a></li>
<li><a href="/dcs/1618405201.html">Elasticsearch7学习笔记(中)</a></li>
<li><a href="/dcs/1618405202.html">Elasticsearch7学习笔记(下)</a></li>
<li><a href="/java/1610333320.html">Elasticsearch7学习笔记(实战)</a></li>
</ul>
<h2 id="一、Elasticsearch基础"><a href="#一、Elasticsearch基础" class="headerlink" title="一、Elasticsearch基础"></a>一、Elasticsearch基础</h2><p>现在主流的搜索引擎大概就是：Lucene，Solr，ElasticSearch。这里是对ElasticSearch的学习。</p>
<h3 id="1-1-Elasticsearch的功能"><a href="#1-1-Elasticsearch的功能" class="headerlink" title="1.1 Elasticsearch的功能"></a>1.1 Elasticsearch的功能</h3><ol>
<li><p>分布式的搜索引擎和数据分析引擎</p>
<ul>
<li>搜索：百度，网站的站内搜索，IT系统的检索； </li>
<li>数据分析：电商网站，最近7天牙膏这种商品销量排名前10的商家有哪些；新闻网站，最近1个月访问量排名前3的新闻版块是哪些 分布式，搜索，数据分析</li>
</ul>
</li>
<li><p>全文检索，结构化检索，数据分析 </p>
<ul>
<li>全文检索：我想搜索商品名称包含牙膏的商品，<code>select * from products where product_name like &quot;%牙膏%&quot;</code></li>
<li>结构化检索：我想搜索商品分类为日化用品的商品都有哪些，<code>select * from products where category_id=&#39;日化用品&#39;</code>部分匹配、自动完成、搜索纠错、搜索推荐</li>
<li>数据分析：我们分析每一个商品分类下有多少个商品，<code>select category_id,count(*) from products group by category_id</code></li>
</ul>
</li>
<li><p>对海量数据进行近实时的处理</p>
<ul>
<li>分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索</li>
<li>海联数据的处理：分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了</li>
<li>近实时：检索个数据要花费1小时（这就不要近实时，离线批处理，batch-processing）；在秒级别对数据进行搜索和分析</li>
<li>跟分布式/海量数据相反的：lucene，单机应用，只能在单台服务器上使用，最多只能处理单台服务器可以处理的数据量</li>
</ul>
</li>
</ol>
<h3 id="1-2-Elasticsearch的适用场景"><a href="#1-2-Elasticsearch的适用场景" class="headerlink" title="1.2 Elasticsearch的适用场景"></a>1.2 Elasticsearch的适用场景</h3><h5 id="国外"><a href="#国外" class="headerlink" title="国外"></a>国外</h5><p>（1）维基百科，类似百度百科，牙膏，牙膏的维基百科，全文检索，高亮，搜索推荐</p>
<p>（2）The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜）</p>
<p>（3）Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案</p>
<p>（4）GitHub（开源代码管理），搜索上千亿行代码</p>
<p>（5）电商网站，检索商品</p>
<p>（6）日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch+logstash+kibana）</p>
<p>（7）商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买</p>
<p>（8）BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，**区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘，Kibana进行数据可视化</p>
<h5 id="国内"><a href="#国内" class="headerlink" title="国内"></a>国内</h5><p>（9）国内：站内搜索（电商，招聘，门户，等等），IT系统搜索（OA，CRM，ERP，等等），数据分析（ES热门的一个使用场景）</p>
<h3 id="1-3-elasticsearch的核心概念"><a href="#1-3-elasticsearch的核心概念" class="headerlink" title="1.3 elasticsearch的核心概念"></a>1.3 elasticsearch的核心概念</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">Elasticsearch	数据库
    
-----------------------------------------

Document		行
Type			表（在7.x以后已经移除了，默认为_doc; 在6.x以后一个索引只能有一个type了，在5.x以前一个索引可以有多个type）
Index			库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（1）Near Realtime（NRT）：近实时，两个意思，从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级</p>
<p>（2）Cluster：集群，包含多个节点，每个节点属于哪个集群是通过一个配置（集群名称，默认是elasticsearch）来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常</p>
<p>（3）Node：节点，集群中的一个节点，节点也有一个名称（默认是随机分配的），节点名称很重要（在执行运维管理操作的时候），默认节点会去加入一个名称为“elasticsearch”的集群，如果直接启动一堆节点，那么它们会自动组成一个elasticsearch集群，当然一个节点也可以组成一个elasticsearch集群</p>
<p>（4）Document&amp;field：文档，es中的最小数据单元，一个document可以是一条客户数据，一条商品分类数据，一条订单数据，通常用JSON数据结构表示，每个index下的type中，都可以去存储多个document。一个document里面有多个field，每个field就是一个数据字段。</p>
<p>（5）Index：索引，包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document。比如说建立一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品document。</p>
<p>（6）shard：单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个shard都是一个lucene index。</p>
<p>（7）replica：任何一个服务器随时可能故障或宕机，此时shard可能就会丢失，因此可以为每个shard创建多个replica副本。replica可以在shard故障时提供备用服务，保证数据不丢失，多个replica还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认5个），replica shard（随时修改数量，默认1个），默认每个索引10个shard，5个primary shard，5个replica shard，最小的高可用配置，是2台服务器。</p>
<h3 id="1-4-使用docker安装Elasticsearch"><a href="#1-4-使用docker安装Elasticsearch" class="headerlink" title="1.4 使用docker安装Elasticsearch"></a>1.4 使用docker安装Elasticsearch</h3><ol>
<li>拉取docker镜像，由于国内网络原因，速度可能会比较慢或者无法下载；可以直接安装对应系统的安装包进行安装即可，基本都是解压运行即可。</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull elasticsearch:7.8.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>镜像下载慢可以配置国内的加速</p>
</blockquote>
<p>编辑编辑<code>/etc/docker/daemon.json</code>文件</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>添加镜像加速地址(下面这个是网易的加速地址)：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&#123;
  &quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>也可以使用申请<a target="_blank" rel="noopener" href="https://www.aliyun.com/activity/daily/bestoffer?userCode=yk3sqxxe">阿里云容器镜像服务ACR</a> ；申请成功后点击管理控制台，选择镜像中心-&gt;镜像加速获取地址。</p>
</blockquote>
<p>重启docker</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl daemon-reload
systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="2">
<li>创建elasticsearch容器，并启动(这里使用单机版)</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -d --name es7  -p 9200:9200 -p 9300:9300 -e &quot;discovery.type&#x3D;single-node&quot; elasticsearch:7.8.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol start="3">
<li>访问 <code>http://192.168.1.6:9200/</code></li>
</ol>
<p>如果正常返回则说明成功，类似：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#123;
  &quot;name&quot; : &quot;074c8527cecd&quot;,
  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,
  &quot;cluster_uuid&quot; : &quot;YBNpiQm8Qxmd0ma7j-1uGw&quot;,
  &quot;version&quot; : &#123;
    &quot;number&quot; : &quot;7.8.0&quot;,
    &quot;build_flavor&quot; : &quot;default&quot;,
    &quot;build_type&quot; : &quot;docker&quot;,
    &quot;build_hash&quot; : &quot;757314695644ea9a1dc2fecd26d1a43856725e65&quot;,
    &quot;build_date&quot; : &quot;2020-06-14T19:35:50.234439Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;8.5.1&quot;,
    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,
    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;
  &#125;,
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二、Kibana"><a href="#二、Kibana" class="headerlink" title="二、Kibana"></a>二、Kibana</h2><p>kibana的界面可以很方便的查看elasticsearch的信息，也可以做图表、指标等。同时提供控制台命令操作elasticsearch。我们后面的es查询操作都在这个上面操作了。</p>
<h3 id="使用docker安装kibana"><a href="#使用docker安装kibana" class="headerlink" title="使用docker安装kibana"></a>使用docker安装kibana</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 拉取kibana的镜像
docker pull kibana:7.8.0
# 启动kibana
docker run -d --name kibana --link 已经启动的elasticsearch的容器ID或者是名字:elasticsearch -p 5601:5601 kibana:7.8.0  
# 例如
docker run -d --name kibana --link es7:elasticsearch -p 5601:5601 kibana:7.8.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过<code>http://192.168.111.44:5601</code>访问kibana</p>
<blockquote>
<p>如果需要中文界面在kibana.yml文件中添加 <code>i18n.locale: &quot;zh-CN&quot;</code>配置重启即可；注意最好和es的版本一样。</p>
</blockquote>
<p><img src="https://media-vchar.oss-cn-hangzhou.aliyuncs.com/image/blog/dsc/kibana-es-cmd.jpg"></p>
<h3 id="通过kibana的Console来做elasticsearch的crud和相关配置"><a href="#通过kibana的Console来做elasticsearch的crud和相关配置" class="headerlink" title="通过kibana的Console来做elasticsearch的crud和相关配置"></a>通过kibana的Console来做elasticsearch的crud和相关配置</h3><h4 id="elasticsearch集群状态"><a href="#elasticsearch集群状态" class="headerlink" title="elasticsearch集群状态"></a>elasticsearch集群状态</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET _cat&#x2F;health?v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>green：每个索引的primary shard和replica shard都是active状态的</li>
<li>yellow：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态</li>
<li>red：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了</li>
</ul>
<blockquote>
<p>后面加v是为了打印出更多的信息</p>
</blockquote>
<h4 id="索引相关操作"><a href="#索引相关操作" class="headerlink" title="索引相关操作"></a>索引相关操作</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 查询所有索引
GET _cat&#x2F;indices?v
# 创建索引
PUT &#x2F;索引名称?pretty
# 删除索引
DELETE &#x2F;索引名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="向elasticsearch中添加和修改数据"><a href="#向elasticsearch中添加和修改数据" class="headerlink" title="向elasticsearch中添加和修改数据"></a>向elasticsearch中添加和修改数据</h4><p>语法, 使用POST或者PUT都可以，存在则更新否则创建；</p>
<blockquote>
<p>区别在于没有加ID值时（没有ID会自动生成），只能用POST表示创建；<br>需要注意的是使用PUT做更新时，其实是直接覆盖，因此需要带上所有的数据；</p>
</blockquote>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;索引名称&#x2F;_doc
POST &#x2F;索引名称&#x2F;_create

POST &#x2F;索引名称&#x2F;_doc&#x2F;数据的id值
POST &#x2F;索引名称&#x2F;_create&#x2F;数据的id值

PUT &#x2F;索引名称&#x2F;_doc&#x2F;数据的id值
PUT &#x2F;索引名称&#x2F;_create&#x2F;数据的id值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只更新指定字段的值：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST&#x2F;索引名称&#x2F;_update&#x2F;数据的ID值 &#123;
    &quot;doc&quot;:&#123;
        &#x2F;&#x2F; 更新内容
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 查询所有
GET &#x2F;索引名称&#x2F;_search
# 根据ID查询
GET &#x2F;索引名称&#x2F;_doc&#x2F;数据的id值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">DELETE &#x2F;索引名称&#x2F;_doc&#x2F;数据的id值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>删除使用的逻辑删除，之后会统一进行物理删除</p>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 添加或更新替换
POST &#x2F;ecommerce&#x2F;_doc&#x2F;1
&#123;
  &quot;name&quot;:&quot;小米手机&quot;,
  &quot;desc&quot;:&quot;支持5G、全面屏6.4&quot;,
  &quot;price&quot;:3000,
  &quot;producer&quot;:&quot;小米&quot;,
  &quot;tags&quot;:[&quot;mobile&quot;,&quot;5G&quot;]
&#125;

# 添加或更新替换
PUT &#x2F;ecommerce&#x2F;_doc&#x2F;2
&#123;
  &quot;name&quot;:&quot;华为MacBook&quot;,
  &quot;desc&quot;:&quot;支持5G、全面屏15.2寸&quot;,
  &quot;price&quot;:8000,
  &quot;producer&quot;:&quot;Huawei&quot;,
  &quot;tags&quot;:[&quot;笔记本电脑&quot;,&quot;huawei&quot;]
&#125;

# 添加或更新替换
POST &#x2F;ecommerce&#x2F;_create&#x2F;3
&#123;
  &quot;name&quot;:&quot;华为P40 pro&quot;,
  &quot;desc&quot;:&quot;支持5G、超清摄像&quot;,
  &quot;price&quot;:12000,
  &quot;producer&quot;:&quot;Huawei 成都&quot;,
  &quot;tags&quot;:[&quot;mobile&quot;,&quot;huawei&quot;,&quot;5G&quot;]
&#125;

# 添加
POST &#x2F;ecommerce&#x2F;_doc
&#123;
  &quot;name&quot;:&quot;Ipad mini 5&quot;,
  &quot;desc&quot;:&quot;7.9英寸&quot;,
  &quot;price&quot;:4000,
  &quot;producer&quot;:&quot;apple&quot;,
  &quot;tags&quot;:[&quot;笔记本电脑&quot;,&quot;apple&quot;]
&#125;

# 更新
POST &#x2F;ecommerce&#x2F;_update&#x2F;1
&#123;
  &quot;doc&quot;: &#123;
    &quot;price&quot;:2000
  &#125;
&#125;

# 查询
GET &#x2F;ecommerce&#x2F;_search
GET &#x2F;ecommerce&#x2F;_doc&#x2F;1

# 删除
DELETE &#x2F;ecommerce&#x2F;_doc&#x2F;4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="elasticsearch查询语句示例"><a href="#elasticsearch查询语句示例" class="headerlink" title="elasticsearch查询语句示例"></a>elasticsearch查询语句示例</h3><h4 id="query-string-search"><a href="#query-string-search" class="headerlink" title="query string search"></a>query string search</h4><p><code>query string search</code>就是将查询条件放到http的参数上</p>
<p>1、查询全部</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>返回字段说明：</strong></p>
<ul>
<li>took：耗费了几毫秒</li>
<li>timed_out：是否超时</li>
<li>_shards：数据拆成几个分片，所以对于搜索请求，会打到所有的primary shard（或者是它的某个replica shard也可以）</li>
<li>hits.total：查询结果的数量，即几个document</li>
<li>hits.max_score：score的含义，就是document对于一个search的相关度的匹配分数，越相关，就越匹配，分数也高</li>
<li>hits.hits：包含了匹配搜索的document的详细数据</li>
</ul>
<p>2、查询名称包含<code>华为</code>的商品,并且按照售价降序排序</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search?q&#x3D;name:华为&amp;sort&#x3D;price:desc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>3、只返回name、price字段</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search?_source&#x3D;name,price<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="query-DSL"><a href="#query-DSL" class="headerlink" title="query DSL"></a>query DSL</h4><p>DSL：Domain Specified Language，特定领域的语言</p>
<blockquote>
<p>http request body：请求体，可以用json的格式来构建查询语法，<br>比较方便，可以构建各种复杂的语法，比query string search肯定强大多了</p>
</blockquote>
<p>查询所有match_all</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
    &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询名称包含<code>华为</code>的商品，同时按照价格降序排序</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;name&quot;: &quot;华为&quot;
    &#125;
  &#125;
  , &quot;sort&quot;: [
    &#123;
      &quot;price&quot;: &#123;
        &quot;order&quot;: &quot;desc&quot;
      &#125;
    &#125;
  ]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>分页查询</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;: &#123;&#125;
  &#125;,
  &quot;from&quot;: 2,
  &quot;size&quot;: 2
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>from 从第几条开始，起始为0<br>size 返回多少条记录</p>
</blockquote>
<p>指定返回的字段</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;: &#123;&#125;
  &#125;,
  &quot;_source&quot;: [&quot;name&quot;, &quot;price&quot;]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="query-filter"><a href="#query-filter" class="headerlink" title="query filter"></a>query filter</h4><p>对数据进行过滤</p>
<p>搜索商品名称包含<code>华为</code>，而且售价大于8000元的商品</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
    &quot;query&quot;: &#123;
     &quot;bool&quot;: &#123;
       &quot;must&quot;: [
         &#123;
           &quot;match&quot;: &#123;
             &quot;name&quot;: &quot;华为&quot;
           &#125;
         &#125;
       ],
       &quot;filter&quot;: [
         &#123;
           &quot;range&quot;: &#123;
             &quot;price&quot;: &#123;
               &quot;gt&quot;: 8000
             &#125;
           &#125;
         &#125;
       ]
     &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;bool&quot;: &#123;
      &quot;must&quot;: &#123;
          &quot;match&quot;: &#123;
            &quot;name&quot;: &quot;华为&quot;
          &#125;
        &#125;
      ,
      &quot;filter&quot;: &#123;
          &quot;range&quot;: &#123;
            &quot;price&quot;: &#123;
              &quot;gt&quot;: 8000
            &#125;
          &#125;
        &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>bool 里面可以写多个条件</p>
</blockquote>
<h4 id="full-text-search（全文检索）"><a href="#full-text-search（全文检索）" class="headerlink" title="full-text search（全文检索）"></a>full-text search（全文检索）</h4><p>全文检索会将输入的搜索串拆解开来，去倒排索引里面去一一匹配，只要能匹配上任意一个拆解后的单词，就可以作为结果返回</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
  &quot;query&quot;:&#123;
    &quot;match&quot;: &#123;
      &quot;producer&quot;: &quot;Huawei 成都&quot;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="phrase-search（短语搜索）"><a href="#phrase-search（短语搜索）" class="headerlink" title="phrase search（短语搜索）"></a>phrase search（短语搜索）</h4><p>跟全文检索相对应相反，<code>phrase search</code>要求输入的搜索串，必须在指定的字段文本中，完全包含一模一样的，才可以算匹配，才能作为结果返回</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
  &#123;
    &quot;query&quot;: &#123;
       &quot;match_phrase&quot;: &#123;
         &quot;producer&quot;: &quot;Huawei 成都&quot;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="highlight-search（高亮搜索结果）"><a href="#highlight-search（高亮搜索结果）" class="headerlink" title="highlight search（高亮搜索结果）"></a>highlight search（高亮搜索结果）</h4><p>高亮搜索结果就是将匹配的字段做标识，就像百度搜索中那些匹配的内容是红色显示</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;producer&quot;: &quot;Huawei&quot;
    &#125;
  &#125;,
 &quot;highlight&quot;: &#123;
   &quot;fields&quot;: &#123;
     &quot;producer&quot;: &#123;&#125;
   &#125;
 &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="聚合：计算每个tag下的商品数量"><a href="#聚合：计算每个tag下的商品数量" class="headerlink" title="聚合：计算每个tag下的商品数量"></a>聚合：计算每个tag下的商品数量</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
  &quot;size&quot;: 0, 
  &quot;aggs&quot;: &#123;
   &quot;group_by_tags&quot;:&#123;
     &quot;terms&quot;: &#123;
       &quot;field&quot;: &quot;tags&quot;
     &#125;
   &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>group_by_tags 是随意取的一个名字，待会的查询统计结果会放到这个字段中<br>加size是不返回原始数据</p>
</blockquote>
<p>上面那样操作会报错，需要先执行下面的语句，更新tags字段的fielddata属性设置为true</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;ecommerce&#x2F;_mapping
&#123;
  &quot;properties&quot;:&#123;
    &quot;tags&quot;:&#123;
      &quot;type&quot;:&quot;text&quot;,
      &quot;fielddata&quot;:true
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="聚合：对名称中包含yagao的商品，计算每个tag下的商品数量"><a href="#聚合：对名称中包含yagao的商品，计算每个tag下的商品数量" class="headerlink" title="聚合：对名称中包含yagao的商品，计算每个tag下的商品数量"></a>聚合：对名称中包含yagao的商品，计算每个tag下的商品数量</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
  &quot;size&quot;: 0, 
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;name&quot;: &quot;华为&quot;
    &#125;
  &#125;,
  &quot;aggs&quot;: &#123;
    &quot;all_tags&quot;: &#123;
      &quot;terms&quot;: &#123;
        &quot;field&quot;: &quot;tags&quot;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>先执行query条件查询，然后对结果做aggs聚合处理</p>
</blockquote>
<h4 id="聚合：计算每个tag下的商品的平均价格（先分组再平均）"><a href="#聚合：计算每个tag下的商品的平均价格（先分组再平均）" class="headerlink" title="聚合：计算每个tag下的商品的平均价格（先分组再平均）"></a>聚合：计算每个tag下的商品的平均价格（先分组再平均）</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
  &quot;size&quot;: 0, 
  &quot;aggs&quot;: &#123;
    &quot;group_by_tags&quot;: &#123;
      &quot;terms&quot;: &#123;
        &quot;field&quot;: &quot;tags&quot;
      &#125;,
      &quot;aggs&quot;: &#123;
        &quot;avg_price&quot;: &#123;
          &quot;avg&quot;: &#123;
            &quot;field&quot;: &quot;price&quot;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="计算每个tag下的商品的平均价格，并且按照平均价格降序排序"><a href="#计算每个tag下的商品的平均价格，并且按照平均价格降序排序" class="headerlink" title="计算每个tag下的商品的平均价格，并且按照平均价格降序排序"></a>计算每个tag下的商品的平均价格，并且按照平均价格降序排序</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
  &quot;size&quot;: 0
  , &quot;aggs&quot;: &#123;
    &quot;all_tags&quot;: &#123;
      &quot;terms&quot;: &#123;
        &quot;field&quot;: &quot;tags&quot;, &quot;order&quot;: &#123;
          &quot;avg_price&quot;: &quot;desc&quot;
        &#125;
      &#125;,
      &quot;aggs&quot;: &#123;
        &quot;avg_price&quot;: &#123;
          &quot;avg&quot;: &#123;
            &quot;field&quot;: &quot;price&quot;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格"><a href="#按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格" class="headerlink" title="按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格"></a>按照指定的价格范围区间进行分组，然后在每组内再按照tag进行分组，最后再计算每组的平均价格</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_search
&#123;
  &quot;size&quot;: 0, 
  &quot;aggs&quot;: &#123;
    &quot;group_by_price&quot;: &#123;
      &quot;range&quot;: &#123;
        &quot;field&quot;: &quot;price&quot;,
        &quot;ranges&quot;: [
          &#123;
            &quot;from&quot;: 0,
            &quot;to&quot;: 5000
          &#125;,
          &#123;
            &quot;from&quot;: 6000
          &#125;
        ]
      &#125;,
      &quot;aggs&quot;: &#123;
        &quot;group_by_tags&quot;: &#123;
          &quot;terms&quot;: &#123;
            &quot;field&quot;: &quot;tags&quot;
          &#125;,
          &quot;aggs&quot;: &#123;
            &quot;avg_price&quot;: &#123;
              &quot;avg&quot;: &#123;
                &quot;field&quot;: &quot;price&quot;
              &#125;
            &#125;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="cerebro"><a href="#cerebro" class="headerlink" title="cerebro"></a>cerebro</h3><p>这个是个es的监控软件，可以很方便的查询es集群的分片等情况，能集中管理alias和index template；在kibana中需要使用命令才可以实现，可以根据自己需要来安装。</p>
<p>拉取镜像：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull yannart&#x2F;cerebro<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>启动容器：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -d -p 9000:9000 --name cerebro yannart&#x2F;cerebro:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>浏览器访问9000: <code>http://ip:9000</code>；直接输入es的连接地址即可，如：<code>http://192.168.6.2:9200</code></p>
<h4 id="在一台机器上导致连接失败的问题"><a href="#在一台机器上导致连接失败的问题" class="headerlink" title="在一台机器上导致连接失败的问题"></a>在一台机器上导致连接失败的问题</h4><p>由于资源有限，上面这些组件全部都放在了一机器上导致无法访问，需要打开防火墙开放端口才可以；</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#查看防火墙状态
systemctl status firewalld

#重启防火墙
systemctl restart firewalld.service

#查看已经开放的端口
firewall-cmd --zone&#x3D;public --list-ports

#开放如下端口（第二个可选）
firewall-cmd --zone&#x3D;public --add-port&#x3D;9200&#x2F;tcp --permanent &amp;&amp; firewall-cmd --reload
firewall-cmd --zone&#x3D;public --add-port&#x3D;9300&#x2F;tcp --permanent &amp;&amp; firewall-cmd --reload
firewall-cmd --zone&#x3D;public --add-port&#x3D;5601&#x2F;tcp --permanent &amp;&amp; firewall-cmd --reload
firewall-cmd --zone&#x3D;public --add-port&#x3D;9000&#x2F;tcp --permanent &amp;&amp; firewall-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样容器间就可以相互访问了（开启防火墙后可能需要重启docker服务才行）</p>
<h2 id="三、Elasticsearch-的分布式集群"><a href="#三、Elasticsearch-的分布式集群" class="headerlink" title="三、Elasticsearch 的分布式集群"></a>三、Elasticsearch 的分布式集群</h2><p><img src="https://media-vchar.oss-cn-hangzhou.aliyuncs.com/image/blog/dsc/es-001.jpg"></p>
<h3 id="shard-amp-replica机制"><a href="#shard-amp-replica机制" class="headerlink" title="shard&amp;replica机制"></a>shard&amp;replica机制</h3><p>（1）index包含多个shard</p>
<p>（2）每个shard都是一个最小工作单元，承载部分数据，lucene实例，完整的建立索引和处理请求的能力</p>
<p>（3）增减节点时，shard会自动在nodes中负载均衡</p>
<p>（4）primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard</p>
<p>（5）replica shard是primary shard的副本，负责容错，以及承担读请求负载</p>
<p>（6）primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改</p>
<p>（7）primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard</p>
<p>（8）primary shard不能和自己的replica shard放在同一个节点上（否则节点宕机，primary shard和副本都丢失，起不到容错的作用），但是可以和其他primary shard的replica shard放在同一个节点上</p>
<p>（9）相同primary shard的replica shard不能放在同一个节点上；（节点宕机时，replica shard副本都丢失，起不到容错的作用）</p>
<h3 id="单node环境下创建index"><a href="#单node环境下创建index" class="headerlink" title="单node环境下创建index"></a>单node环境下创建index</h3><p>（1）单node环境下，创建一个index，有3个primary shard，3个replica shard</p>
<p>（2）集群status是yellow</p>
<p>（3）这个时候，只会将3个primary shard分配到仅有的一个node上去，另外3个replica shard是无法分配的</p>
<p>（4）集群可以正常工作，但是一旦出现节点宕机，数据全部丢失，而且集群不可用，无法承接任何请求</p>
<h2 id="四、Elasticsearch内部相关实现"><a href="#四、Elasticsearch内部相关实现" class="headerlink" title="四、Elasticsearch内部相关实现"></a>四、Elasticsearch内部相关实现</h2><h3 id="并发数据修改控制"><a href="#并发数据修改控制" class="headerlink" title="并发数据修改控制"></a>并发数据修改控制</h3><p>Elasticsearch内部是多线程异步并发的进行修改（即可能出现后修改的先处理），采用version进行乐观锁；</p>
<p>具体原理： Elasticsearch每次执行更新和删除操作成功时，它的version都会自动加1， 每次执行更新删除时会带上版本号，如果版本号不一致，则会放弃此次操作；这样就保证了后修改的先执行的情况能够正常处理，不会被先修改的覆盖掉。</p>
<h4 id="示例：在更新的时候带上版本号参数"><a href="#示例：在更新的时候带上版本号参数" class="headerlink" title="示例：在更新的时候带上版本号参数"></a>示例：在更新的时候带上版本号参数</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;ecommerce&#x2F;_update&#x2F;2?version&#x3D;3
&#123;
  &quot;doc&quot;:&#123;
    &quot;tags&quot;:[&quot;laptop &quot;, &quot;Huawei&quot;]
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>当版本号version不匹配的时候会更新失败</p>
</blockquote>
<h3 id="使用external-version来进行乐观锁并发控制"><a href="#使用external-version来进行乐观锁并发控制" class="headerlink" title="使用external version来进行乐观锁并发控制"></a>使用external version来进行乐观锁并发控制</h3><p>es提供了一个feature，就是可以不用它提供的内部_version版本号来进行并发控制，可以基于你自己维护的一个版本号来进行并发控制。</p>
<p>举个列子: 假如你的数据在mysql里也有一份，然后你的应用系统本身就维护了一个版本号，无论是什么自己生成的，程序控制的。 这个时候，你进行乐观锁并发控制的时候，可能并不是想要用es内部的_version来进行控制，而是用你自己维护的那个version来进行控制。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;ecommerce&#x2F;_doc&#x2F;1?version&#x3D;2&amp;version_type&#x3D;external
&#123;
    &quot;name&quot; : &quot;小米10Pro&quot;,
    &quot;desc&quot; : &quot;支持5G、全面屏6.4&quot;,
    &quot;price&quot; : 3000,
    &quot;producer&quot; : &quot;小米&quot;,
    &quot;tags&quot; : [
      &quot;xiaomi&quot;,
      &quot;mobile&quot;,
      &quot;5G&quot;
    ]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>在后面多加一个<code>version_type=external</code>参数，只有version版本比当前ES维护的版本号大就可以更新成功</p>
</blockquote>
<h3 id="partial-update说明"><a href="#partial-update说明" class="headerlink" title="partial update说明"></a>partial update说明</h3><p>语法（url地址后面可以加版本号?version=1）：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;索引名称&#x2F;_update&#x2F;ID值
&#123;
  &quot;doc&quot;:&#123;
        &#x2F;&#x2F; 更新字段信息
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用partial update进行更新其实际执行过程如下：</p>
<ol>
<li>内部先获取document；</li>
<li>将传过来的field更新到document的json中去；</li>
<li>将原来的document标记为删除状态；</li>
<li>将修改后的新的document创建出来；</li>
</ol>
<blockquote>
<p>实际上和传统的全量替换几乎一样。 注意：如果document不存在会报错</p>
</blockquote>
<p>同时partial update将自动执行基于version的乐观锁并发控制</p>
<p>设置在发送冲突时进行重试的次数</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;ecommerce&#x2F;_update&#x2F;1?retry_on_conflict&#x3D;2
&#123;
  &quot;doc&quot;: &#123;
    &quot;price&quot;:3000
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>所有查询、修改和写回操作都发生在es的一个shard内部，几乎避免了所有的网络数据传输开销，提升性能；</li>
<li>减少了查询和修改的时间间隔，能够有效的减少并发的冲突的情况；（因为其内部操作几乎在毫秒级别）</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;ecommerce&#x2F;_update&#x2F;1
&#123;
  &quot;doc&quot;:&#123;
        &quot;name&quot; : &quot;小米10&quot;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="es的脚本支持：groovy"><a href="#es的脚本支持：groovy" class="headerlink" title="es的脚本支持：groovy"></a>es的脚本支持：groovy</h3><h4 id="使用内置脚本来做累加操作"><a href="#使用内置脚本来做累加操作" class="headerlink" title="使用内置脚本来做累加操作"></a>使用内置脚本来做累加操作</h4><p>将price加1</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;ecommerce&#x2F;_update&#x2F;1
&#123;
  &quot;script&quot;: &quot;ctx._source.price+&#x3D;1&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="外置脚本"><a href="#外置脚本" class="headerlink" title="外置脚本"></a>外置脚本</h4><p>这个相当于关系型数据库的存储过程，将需要执行的脚本放到es的<code>config/scripts</code>目录下； 如在<code>config/scripts</code>目录下创建一个名为<code>add-price.groovy</code>文件，在里面写入如下脚本：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">ctx._source.price+&#x3D;add_price<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>执行这个脚本：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;ecommerce&#x2F;_update&#x2F;1
&#123;
  &quot;script&quot;: &#123;
    &quot;lang&quot;: &quot;groovy&quot;,
    &quot;file&quot;: &quot;add-price&quot;,
    &quot;params&quot;: &#123;
      &quot;add_price&quot;:1
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="示例删除document的脚本"><a href="#示例删除document的脚本" class="headerlink" title="示例删除document的脚本"></a>示例删除document的脚本</h5><p>在<code>config/scripts</code>目录下创建一个名为<code>del-doc.groovy</code>文件，在里面写入如下脚本：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">ctx.op &#x3D; ctx._source.price&gt;price?&#39;delete&#39;:&#39;none&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>执行脚本</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;ecommerce&#x2F;_update&#x2F;1
&#123;
  &quot;script&quot;: &#123;
    &quot;lang&quot;: &quot;groovy&quot;,
    &quot;file&quot;: &quot;del-doc&quot;,
    &quot;params&quot;: &#123;
      &quot;price&quot;:5000
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="upsert的使用"><a href="#upsert的使用" class="headerlink" title="upsert的使用"></a>upsert的使用</h4><p>解决当在执行更新时document不存在导致更新失败的问题。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;ecommerce&#x2F;_update&#x2F;1
&#123;
  &quot;script&quot;: &quot;ctx._source.price+&#x3D;1&quot;,
  &quot;upsert&quot;: &#123;
    &quot;price&quot;:0,
    &quot;tags&quot;:[]
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>upsert就是没有的时候对document进行初始化</p>
</blockquote>
<h3 id="mget批量查询"><a href="#mget批量查询" class="headerlink" title="_mget批量查询"></a>_mget批量查询</h3><p>普通的查询方式只能一条一条的查询，使用mget可以实现批量查询，减少网络开销</p>
<h4 id="查询ID为1和2的数据"><a href="#查询ID为1和2的数据" class="headerlink" title="查询ID为1和2的数据"></a>查询ID为1和2的数据</h4><p>不同的index</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_mget
&#123;
  &quot;docs&quot;:[
    &#123;
      &quot;_index&quot;:&quot;ecommerce&quot;,
      &quot;_id&quot;:1
    &#125;,
        &#123;
      &quot;_index&quot;:&quot;goods&quot;,
      &quot;_id&quot;:2
    &#125;
    ]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同一个index</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_mget
&#123;
  &quot;docs&quot;:[
    &#123;
      &quot;_id&quot;:1
    &#125;,
    &#123;
      &quot;_id&quot;:2
    &#125;
    ]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同一个index且相同的filed</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_mget
&#123;
  &quot;ids&quot;:[1,2]
  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对返回的source字段进行过滤</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;ecommerce&#x2F;_mget
&#123;
  &quot;docs&quot;:[
    &#123;
      &quot;_id&quot;:1,
      &quot;_source&quot;:[&quot;price&quot;,&quot;name&quot;]
    &#125;,
    &#123;
      &quot;_id&quot;:2,
      &quot;_source&quot;:&quot;price&quot;
    &#125;,
    &#123;
      &quot;_id&quot;:3,
      &quot;_source&quot;:false
    &#125;
    ]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意直接用ids来查询时不能进行字段过滤</p>
</blockquote>
<h3 id="bulk批量增删改"><a href="#bulk批量增删改" class="headerlink" title="_bulk批量增删改"></a>_bulk批量增删改</h3><ul>
<li>create：创建</li>
<li>delete：删除</li>
<li>update：更新</li>
</ul>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;_bulk
&#123;&quot;delete&quot;:&#123;&quot;_index&quot;:&quot;ecommerce&quot;,&quot;_id&quot;:3&#125;&#125;
&#123;&quot;create&quot;:&#123;&quot;_index&quot;:&quot;ecommerce&quot;,&quot;_id&quot;:3&#125;&#125;
&#123;&quot;price&quot;:5000&#125;
&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;ecommerce&quot;,&quot;_id&quot;:3&#125;&#125;
&#123;&quot;doc&quot;:&#123;&quot;price&quot;:6000&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>一条语句不能有换行这些，直接一行；在create之后可以添加需要添加的属性；update的更新属性需要加<code>doc</code>；如果在一个index中可以不写index，直接跟在url上即可。</p>
</blockquote>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;ecommerce&#x2F;_bulk
&#123;&quot;delete&quot;:&#123;&quot;_id&quot;:3&#125;&#125;
&#123;&quot;create&quot;:&#123;&quot;_id&quot;:3&#125;&#125;
&#123;&quot;price&quot;:5000&#125;
&#123;&quot;update&quot;:&#123;&quot;_id&quot;:3&#125;&#125;
&#123;&quot;doc&quot;:&#123;&quot;price&quot;:6000&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>_bulk在执行的时候，如果其中有一条语句执行失败，不会影响其他的执行，会在返回结果中将异常提示返回</p>
<h4 id="bulk-size最佳大小"><a href="#bulk-size最佳大小" class="headerlink" title="bulk size最佳大小"></a>bulk size最佳大小</h4><p>bulk request会加载到内存里，如果太大的话，性能反而会下降，因此需要反复尝试一个最佳的bulk size。 一般从1000到5000条数据开始，尝试逐渐增加。另外，如果看大小的话，最好是在5~15MB之间。</p>
<h3 id="什么是distributed-document-store？"><a href="#什么是distributed-document-store？" class="headerlink" title="什么是distributed document store？"></a>什么是distributed document store？</h3><p>围绕着document在操作，其实就是把es当成了一个NoSQL存储引擎，一个可以存储文档类型数据的存储系统，操作里面的document。</p>
<p>适合的的应用程序类型</p>
<p>（1）数据量较大，es的分布式本质，可以帮助你快速进行扩容，承载大量数据</p>
<p>（2）数据结构灵活多变，随时可能会变化，而且数据结构之间的关系，非常复杂，如果我们用传统数据库，那是不是很坑，因为要面临大量的表</p>
<p>（3）对数据的相关操作，较为简单，比如就是一些简单的增删改查，用我们之前讲解的那些document操作就可以搞定</p>
<p>（4）NoSQL数据库，适用的也是类似于上面的这种场景</p>
<h3 id="document数据路由原理"><a href="#document数据路由原理" class="headerlink" title="document数据路由原理"></a>document数据路由原理</h3><p>（1）document路由到shard上是什么意思？</p>
<p>一个index的数据会被分为多片，每片都在一个shard中，因此一个document只能存在一个shard中； 当有一个document需要操作时，es就需要知道这个document是放在index的那个shard上的。 这个过程就称之为document的数据路由。</p>
<p>（2）路由算法：<code>shard = hash(routing) % number_of_primary_shards</code></p>
<p>举个例子来简要说明下这个算法： 一个index有3个primary shard（分别为P0，P1，P2），每次增删改查一个document的时候，都会带过来一个routing number， 默认就是这个document的_id（可能是手动指定，也可能是自动生成）routing = _id，假设_id=1；将这个routing值传入一个hash函数中，产出一个routing值的hash值； 然后将hash函数产出的值对这个index的primary shard的数量求余数，根据这个余数的值决定document放在那个shard上。</p>
<blockquote>
<p>决定一个document在哪个shard上，最重要的一个值就是routing值，默认是_id，也可以手动指定，保证相同的routing值，每次过来，从hash函数中，产出的hash值一定是相同的；<br>这也是为什么ES启动后设置好primary_shards数量之后，primary_shards的数量不能再更改了的原因</p>
</blockquote>
<h3 id="document增删改内部原理"><a href="#document增删改内部原理" class="headerlink" title="document增删改内部原理"></a>document增删改内部原理</h3><ul>
<li>（1）客户端选择一个node发送请求过去，这个node就是coordinating node（协调节点）</li>
<li>（2）coordinating node，对document进行路由，将请求转发给对应的node（有primary shard）</li>
<li>（3）实际的node上的primary shard处理请求，然后将数据同步到replica node</li>
<li>（4）coordinating node，如果发现primary node和所有replica node都搞定之后，就返回响应结果给客户端</li>
</ul>
<p><img src="https://media-vchar.oss-cn-hangzhou.aliyuncs.com/image/blog/dsc/es-002.png"></p>
<h3 id="写一致性原理以及quorum机制剖析"><a href="#写一致性原理以及quorum机制剖析" class="headerlink" title="写一致性原理以及quorum机制剖析"></a>写一致性原理以及quorum机制剖析</h3><p>我们在发送任何一个增删改操作的时候，比如说<code>put /index/_doc/id</code>，都可以带上一个<code>consistency</code>参数，指明我们想要的写一致性是什么？</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">put &#x2F;index&#x2F;_doc&#x2F;id?consistency&#x3D;quorum<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>consistency，one（primary shard），all（all shard），quorum（default）</p>
</blockquote>
<ul>
<li>one：要求我们这个写操作，只要有一个primary shard是active活跃可用的，就可以执行</li>
<li>all：要求我们这个写操作，必须所有的primary shard和replica shard都是活跃的，才可以执行这个写操作</li>
<li>quorum：默认的值，要求所有的shard中，必须是大部分的shard都是活跃的，可用的，才可以执行这个写操作</li>
</ul>
<h4 id="quorum机制，写之前必须确保大多数shard都可用（也就是半数以上）"><a href="#quorum机制，写之前必须确保大多数shard都可用（也就是半数以上）" class="headerlink" title="quorum机制，写之前必须确保大多数shard都可用（也就是半数以上）"></a>quorum机制，写之前必须确保大多数shard都可用（也就是半数以上）</h4><p>计算公式：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">quorum &#x3D; int( (primary + number_of_replicas) &#x2F; 2 ) + 1，当number_of_replicas&gt;1时才生效；active状态的的shard数&gt;&#x3D;quorum才可以执行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>举个例子：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">3个primary shard，number_of_replicas&#x3D;1，总共有3 + 3 * 1 &#x3D; 6个shard
quorum &#x3D; int( (3 + 1) &#x2F; 2 ) + 1 &#x3D; 3
所以，要求6个shard中至少有3个shard是active状态的，才可以执行写操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="如果节点数少于quorum数量，可能导致quorum不齐全，进而导致无法执行任何写操作"><a href="#如果节点数少于quorum数量，可能导致quorum不齐全，进而导致无法执行任何写操作" class="headerlink" title="如果节点数少于quorum数量，可能导致quorum不齐全，进而导致无法执行任何写操作"></a>如果节点数少于quorum数量，可能导致quorum不齐全，进而导致无法执行任何写操作</h4><ul>
<li><p>例子1：3个primary shard，replica=1，要求至少3个shard是active，3个shard按照之前学习的shard&amp;replica机制，必须在不同的节点上，如果只有1台机器，是不是有可能出现3个shard都没法分配齐全，此时就可能会出现写操作无法执行的情况。</p>
</li>
<li><p>例子2：1个primary shard，replica=3，quorum=((1 + 3) / 2) + 1 = 3，要求1个primary shard + 3个replica shard = 4个shard，其中必须有3个shard是要处于active状态的。如果这个时候只有2台机器的话，会出现什么情况呢？</p>
</li>
</ul>
<p>因此es提供了一种特殊的处理场景，当<code>number_of_replicas&gt;1</code>时才生效，因为假如就一个primary shard，replica=1，此时就2个shard <code>(1 + 1 / 2) + 1 = 2</code>，要求必须有2个shard是活跃的，但是可能就1个node，此时就1个shard是活跃的，如果你不特殊处理的话，导致我们的单节点集群就无法工作。</p>
<h4 id="quorum不齐全时，wait，默认1分钟，timeout，100，30s"><a href="#quorum不齐全时，wait，默认1分钟，timeout，100，30s" class="headerlink" title="quorum不齐全时，wait，默认1分钟，timeout，100，30s"></a>quorum不齐全时，wait，默认1分钟，timeout，100，30s</h4><p>等待期间，期望活跃的shard数量可以增加，最后实在不行，就会timeout。</p>
<p>我们其实可以在写操作的时候，加一个timeout参数，比如说<code>put /index/type/id?timeout=30</code>，这个就是自己去设定quorum不满足条件的时候，es的timeout时长，可以缩短，也可以增长。</p>
<h3 id="document查询内部原理"><a href="#document查询内部原理" class="headerlink" title="document查询内部原理"></a>document查询内部原理</h3><ol>
<li>客户端发送请求到任意一个node，成为coordinate node；</li>
<li>coordinate node对document进行路由，将请求转发到对应的node，此时会使用round-robin随机轮询算法，在primary shard以及其所有replica中随机选择一个，让读请求负载均衡；</li>
<li>接收请求的node返回document给coordinate node；</li>
<li>coordinate node返回document给客户端；</li>
<li>特殊情况：document如果还在建立索引过程中，可能只有primary shard有，任何一个replica shard都没有，此时可能会导致无法读取到document，但是document完成索引建立之后，primary shard和replica shard就都有了；</li>
</ol>
<p><img src="https://media-vchar.oss-cn-hangzhou.aliyuncs.com/image/blog/dsc/es-003.png"></p>
<h3 id="bulk-api的奇特json格式与底层性能优化关系"><a href="#bulk-api的奇特json格式与底层性能优化关系" class="headerlink" title="bulk api的奇特json格式与底层性能优化关系"></a>bulk api的奇特json格式与底层性能优化关系</h3><p>bulk api奇特的json格式</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&#123;&quot;action&quot;: &#123;&quot;meta&quot;&#125;&#125;\n
&#123;&quot;data&quot;&#125;\n
&#123;&quot;action&quot;: &#123;&quot;meta&quot;&#125;&#125;\n
&#123;&quot;data&quot;&#125;\n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>1、bulk中的每个操作都可能要转发到不同的node的shard去执行</p>
<p>2、如果采用比较良好的json数组格式；允许任意的换行，整个可读性非常棒，读起来很爽，es拿到那种标准格式的json串以后，要按照下述流程去进行处理</p>
<ul>
<li>将json数组解析为JSONArray对象，这个时候，整个数据，就会在内存中出现一份一模一样的拷贝，一份数据是json文本，一份数据是JSONArray对象；</li>
<li>解析json数组里的每个json，对每个请求中的document进行路由；</li>
<li>为路由到同一个shard上的多个请求，创建一个请求数组；</li>
<li>将这个请求数组序列化；</li>
<li>将序列化后的请求数组发送到对应的节点上去；</li>
</ul>
<p>3、耗费更多内存，更多的jvm gc开销</p>
<p>占用更多的内存可能就会积压其他请求的内存使用量，比如说最重要的搜索请求，分析请求，等等，此时就可能会导致其他请求的性能急速下降。另外的话，占用内存更多，就会导致java虚拟机的垃圾回收次数更多，更频繁，每次要回收的垃圾对象更多，耗费的时间更多，导致es的java虚拟机停止工作线程的时间更多。</p>
<p>假如：一个bulk size的请求为10M，共计100个请求就是1GB的内存占用，假设转为json对象后为2GB，如果请求数量更多，那么消耗的内存就就更多了，同时Java虚拟机的垃圾回收也会更加的耗时，导致系统性能下降。</p>
<p>4、使用现在的奇特格式的优点</p>
<ul>
<li>不用将其转换为json对象，不会出现内存中的相同数据的拷贝，直接按照换行符切割json；</li>
<li>对每两个一组的json，读取meta，进行document路由；</li>
<li>直接将对应的json发送到node上去；</li>
</ul>
<p>5、最大的优势在于，不需要将json数组解析为一个JSONArray对象形成一份大数据的拷贝，浪费内存空间，这样可以尽可能地保证性能</p>
<h2 id="五、搜索引擎"><a href="#五、搜索引擎" class="headerlink" title="五、搜索引擎"></a>五、搜索引擎</h2><h3 id="5-1-search结果解析（search-timeout机制说明）"><a href="#5-1-search结果解析（search-timeout机制说明）" class="headerlink" title="5.1 search结果解析（search timeout机制说明）"></a>5.1 search结果解析（search timeout机制说明）</h3><p><img src="https://media-vchar.oss-cn-hangzhou.aliyuncs.com/image/blog/dsc/es-004.png"></p>
<ul>
<li>took：整个搜索请求花费了多少毫秒；</li>
<li>hits.total：本次搜索，返回了几条结果；</li>
<li>hits.max_score：本次搜索的所有结果中，最大的相关度分数是多少，每一条document对于search的相关度，_score分数越大，排位越靠前；</li>
<li>hits.hits：默认查询前10条数据，完整数据，_score降序排序；</li>
<li>timeout：默认无timeout，latency平衡completeness，手动指定timeout，timeout查询执行机制；</li>
<li>shards：shards fail的条件（primary和replica全部挂掉），不影响其他shard。默认情况下来说，一个搜索请求，会打到一个index的所有primary shard上去，每个primary shard都可能会有一个或多个replica shard，所以请求也可以到primary shard的其中一个replica shard上去。</li>
</ul>
<p>带上超时参数：<code>timeout=10ms，timeout=1s，timeout=1m</code></p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_search?timeout&#x3D;10m<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="5-2-multi-index和multi-type搜索模式解析以及搜索原理"><a href="#5-2-multi-index和multi-type搜索模式解析以及搜索原理" class="headerlink" title="5.2 multi-index和multi-type搜索模式解析以及搜索原理"></a>5.2 multi-index和multi-type搜索模式解析以及搜索原理</h3><h4 id="multi-index和multi-type搜索模式"><a href="#multi-index和multi-type搜索模式" class="headerlink" title="multi-index和multi-type搜索模式"></a>multi-index和multi-type搜索模式</h4><p>如何一次性搜索多个index和多个type下的数据:</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_search：               所有索引，所有type下的所有数据都搜索出来
GET &#x2F;index1&#x2F;_search：        指定一个index，搜索其下所有的数据
GET &#x2F;index1,index2&#x2F;_search： 同时搜索两个index下的数据
GET &#x2F;*1,*2&#x2F;_search：         按照通配符去匹配多个索引
GET &#x2F;_all&#x2F;_search            可以代表搜索所有index下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>也可以加删除type属性，但是es</p>
</blockquote>
<h4 id="简单的搜索原理"><a href="#简单的搜索原理" class="headerlink" title="简单的搜索原理"></a>简单的搜索原理</h4><p>客户端发送一个请求，会将请求分发到所有的primary shard上执行，因为每一个shard上都包含部分数据，所有每一个shard上都可能包含搜索请求的结果；如果primary shard有 replica shard，那么请求也会发送到replica shard上去处理</p>
<h3 id="5-3-分页搜索以及deep-paging性能问题"><a href="#5-3-分页搜索以及deep-paging性能问题" class="headerlink" title="5.3 分页搜索以及deep paging性能问题"></a>5.3 分页搜索以及deep paging性能问题</h3><h4 id="使用es进行分页搜索的语法"><a href="#使用es进行分页搜索的语法" class="headerlink" title="使用es进行分页搜索的语法"></a>使用es进行分页搜索的语法</h4><p>size，from</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_search?size&#x3D;10
GET &#x2F;_search?size&#x3D;10&amp;from&#x3D;0
GET &#x2F;_search?size&#x3D;10&amp;from&#x3D;20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="deep-paging"><a href="#deep-paging" class="headerlink" title="deep paging"></a>deep paging</h4><p>搜索很深就是deep paging；会很耗费性能，应当尽量避免。比如查询临近最后一页的数据，而数据在各个分片上，最后需要将各个分片返回的数据进行综合处理，每个分片实际返回数据不是每页的条数。</p>
<h3 id="5-4-快速掌握query-string-search语法以及-all-metadata"><a href="#5-4-快速掌握query-string-search语法以及-all-metadata" class="headerlink" title="5.4 快速掌握query string search语法以及_all metadata"></a>5.4 快速掌握query string search语法以及_all metadata</h3><h4 id="query-string基础语法"><a href="#query-string基础语法" class="headerlink" title="query string基础语法"></a>query string基础语法</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;demo_index&#x2F;_search?q&#x3D;test_field:test
GET &#x2F;demo_index&#x2F;_search?q&#x3D;+test_field:test
GET &#x2F;demo_index&#x2F;_search?q&#x3D;-test_field:test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>使用+号和没有+号是一样，表示包含指定的关键词；-号表示不含</p>
<h4 id="all-metadata的原理和作用"><a href="#all-metadata的原理和作用" class="headerlink" title="_all metadata的原理和作用"></a>_all metadata的原理和作用</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text"># 匹配包含test的数据
GET &#x2F;demo_index&#x2F;_search?q&#x3D;test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>直接可以搜索所有的field，任意一个field包含指定的关键字就可以搜索出来。我们在进行中搜索的时候，不是对document中的每一个field都进行一次搜索；</p>
<p>es中的_all元数据，在建立索引的时候，每插入一条document，它里面包含了多个field，此时，es会自动将多个field的值，全部用字符串的方式串联起来，变成一个长的字符串，作为_all field的值，同时建立索引； 后面如果在搜索的时候，没有对某个field指定搜索，就默认搜索_all field，其中是包含了所有field的值的。</p>
<p>举个例子</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"tom"</span><span class="token punctuation">,</span>
  <span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>
  <span class="token property">"email"</span><span class="token operator">:</span> <span class="token string">"tom@1qq.com"</span><span class="token punctuation">,</span>
  <span class="token property">"address"</span><span class="token operator">:</span> <span class="token string">"beijing"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>tom 25 tom@qq.com beijing</code>，作为这一条document的_all field的值，同时进行分词后建立对应的倒排索引；生产环境通常不使用</p>
<h3 id="5-5-mapping到底是什么？"><a href="#5-5-mapping到底是什么？" class="headerlink" title="5.5 mapping到底是什么？"></a>5.5 mapping到底是什么？</h3><p>自动或手动为index中的type建立的一种数据结构和相关配置，简称为mapping。当添加数据时会dynamic mapping，自动为我们建立index，创建type，以及type对应的mapping，mapping中包含了每个field对应的数据类型，以及如何分词等设置。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>添加一些测试数据</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;website&#x2F;_doc&#x2F;1
&#123;
  &quot;post_date&quot;: &quot;2020-01-01&quot;,
  &quot;title&quot;: &quot;my first article&quot;,
  &quot;content&quot;: &quot;this is my first article in this website&quot;,
  &quot;author_id&quot;: 9527
&#125;

PUT &#x2F;website&#x2F;_doc&#x2F;2
&#123;
  &quot;post_date&quot;: &quot;2020-01-02&quot;,
  &quot;title&quot;: &quot;my second article&quot;,
  &quot;content&quot;: &quot;this is my second article in this website&quot;,
  &quot;author_id&quot;: 9527
&#125;

PUT &#x2F;website&#x2F;_doc&#x2F;3
&#123;
  &quot;post_date&quot;: &quot;2020-01-03&quot;,
  &quot;title&quot;: &quot;my third article&quot;,
  &quot;content&quot;: &quot;this is my third article in this website&quot;,
  &quot;author_id&quot;: 9527
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>尝试如下搜索，只会返回1条数据：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;website&#x2F;_search?q&#x3D;2020
GET &#x2F;website&#x2F;_search?q&#x3D;2020-01-02
GET &#x2F;website&#x2F;_search?q&#x3D;post_date:2020-01-01
GET &#x2F;website&#x2F;_search?q&#x3D;post_date:2020<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看mapping</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;website&#x2F;_mapping<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>搜索结果为什么不一致，因为es自动建立mapping的时候，设置了不同的field不同的data type。不同的data type的分词、搜索等行为是不一样的。所以出现了_all field和post_date field的搜索表现不是我们所期望的。</p>
<h3 id="5-6-精确匹配与全文搜索的对比分析"><a href="#5-6-精确匹配与全文搜索的对比分析" class="headerlink" title="5.6 精确匹配与全文搜索的对比分析"></a>5.6 精确匹配与全文搜索的对比分析</h3><h4 id="精确匹配（exact-value）"><a href="#精确匹配（exact-value）" class="headerlink" title="精确匹配（exact value）"></a>精确匹配（exact value）</h4><p><code>2020-01-01，exact value</code>，搜索的时候，<code>2020-01-01</code> 才能搜索出来；如果你输入一个01，是搜索不出来的。</p>
<h4 id="全文搜索（full-text）"><a href="#全文搜索（full-text）" class="headerlink" title="全文搜索（full text）"></a>全文搜索（full text）</h4><ul>
<li>缩写 vs. 全程：cn vs. china；如2020-01-01，2020 01 01，搜索2020，或者01，都可以搜索出来；china，搜索cn，也可以将china搜索出来</li>
<li>格式转化：like liked likes；likes，搜索like，也可以将likes搜索出来</li>
<li>大小写：Tom vs tom；Tom，搜索tom，也可以将Tom搜索出来</li>
<li>同义词：like vs love；like，搜索love，同义词，也可以将like搜索出来</li>
</ul>
<p>所以全文搜索不只是匹配完整的一个值，而是可以对值进行拆分词语后（分词）进行匹配，也可以通过缩写、时态、大小写、同义词等进行匹配。</p>
<h3 id="5-7-倒排索引核心原理"><a href="#5-7-倒排索引核心原理" class="headerlink" title="5.7 倒排索引核心原理"></a>5.7 倒排索引核心原理</h3><p>倒排索引（Inverted Index）也叫反向索引，有反向索引必有正向索引。通俗地来讲，正向索引是通过key找value，反向索引则是通过value找key。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">doc1：I really liked my small dogs, and I think my mom also liked them.
doc2：He never liked any dogs, so I hope that my mom will not expect me to liked him.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>分词，初步的倒排索引的建立</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">|word  |doc1|doc2|
|:     |:   |:   |
|I     | *	|  * |
|really| *  |    |
|liked | *	|    |
|my	   | *	|  * |
|small | *	|    |
|dogs  | *  |    |
|and   | *  |    |
....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>搜索<code>mother like little dog</code>，不可能有任何结果</p>
<p>这个是不是我们想要的搜索结果，因为在我们看来，mother和mom有区别吗？同义词，都是妈妈的意思。like和liked有区别吗？没有，都是喜欢的意思，只不过一个是现在时，一个是过去时。little和small有区别吗？同义词，都是小小的。dog和dogs有区别吗？狗，只不过一个是单数，一个是复数。</p>
<p>因此正常情况下在建立倒排索引的时候，会执行一个normalization操作，即对拆分出的各个单词进行相应的处理，以提升后面搜索的时候能够搜索到相关联的文档的概率。</p>
<p>重新建立倒排索引，加入normalization，再次用mother liked little dog搜索，就可以搜索到了。</p>
<p><code>mother like little dog</code>会先分词再normalization（时态的转换，单复数的转换，同义词的转换，大小写的转换）</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">mother	--&gt; mom
like	--&gt; like
little	--&gt; little
dog	--&gt; dog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>doc1和doc2都会搜索出来</p>
<h3 id="5-8-分词器的内部组成到底是什么，以及内置分词器的介绍"><a href="#5-8-分词器的内部组成到底是什么，以及内置分词器的介绍" class="headerlink" title="5.8 分词器的内部组成到底是什么，以及内置分词器的介绍"></a>5.8 分词器的内部组成到底是什么，以及内置分词器的介绍</h3><h4 id="什么是分词器"><a href="#什么是分词器" class="headerlink" title="什么是分词器"></a>什么是分词器</h4><p>一个分词器，将一段文本拆分成一个一个的单个的单词，同时对每个单词进行normalization（时态转换，单复数转换），最后将处理好的结果才会拿去建立倒排索引。</p>
<p>切分词语，normalization（提升召回率【recall】）；具体包含如下：</p>
<ul>
<li>recall，召回率：搜索的时候，增加能够搜索到的结果的数量</li>
<li>character filter：在一段文本进行分词之前，先进行预处理，比如说最常见的就是，过滤html标签（<span>hello<span> –&gt; hello），&amp; –&gt; and（I&amp;you –&gt; I and you）</li>
<li>tokenizer：分词，<code>hello you and me --&gt; hello, you, and, me</code></li>
<li>token filter：<code>lowercase，stop word，synonymom，dogs --&gt; dog，liked --&gt; like，Tom --&gt; tom，a/the/an --&gt; 干掉，mother --&gt; mom，small --&gt; little</code></li>
</ul>
<h3 id="5-9-query-string的分词以及mapping"><a href="#5-9-query-string的分词以及mapping" class="headerlink" title="5.9 query string的分词以及mapping"></a>5.9 query string的分词以及mapping</h3><p>query string必须以和index建立时相同的analyzer进行分词；query string对exact value和full text的区别对待</p>
<blockquote>
<p>不同类型的field，可能有的就是full text，有的就是exact value；因此上面进行搜索时查询结果不是我们预期的</p>
</blockquote>
<h4 id="测试分词器"><a href="#测试分词器" class="headerlink" title="测试分词器"></a>测试分词器</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_analyze
&#123;
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;: &quot;Text to analyze&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-10-对mapping再次回炉透彻理解"><a href="#5-10-对mapping再次回炉透彻理解" class="headerlink" title="5.10 对mapping再次回炉透彻理解"></a>5.10 对mapping再次回炉透彻理解</h3><ul>
<li>往es里面直接插入数据，es会自动建立索引，同时建立type以及对应的mapping；</li>
<li>mapping中就自动定义了每个field的数据类型；</li>
<li>不同的数据类型（比如说text和date），可能有的是exact value，有的是full text；</li>
<li>exact value，在建立倒排索引的时候，分词的时候，是将整个值一起作为一个关键词建立到倒排索引中的；full text，会经历各种各样的处理，分词，normalization（时态转换，同义词转换，大小写转换），才会建立到倒排索引中；</li>
<li>同时exact value和full text类型的field就决定了，在一个搜索过来的时候，对exact value field或者是full text field进行搜索的行为也是不一样的，会跟建立倒排索引的行为保持一致；比如exact value搜索的时候，就是直接按照整个值进行匹配，full text query string 也会进行分词和normalization再去倒排索引中去搜索；</li>
<li>可以用es的dynamic mapping，让其自动建立mapping，包括自动设置数据类型；也可以提前手动创建index和type的mapping，自己对各个field进行设置，包括数据类型，包括索引行为，包括分词器等等；</li>
</ul>
<p>mapping，就是index的type的元数据，每个type都有一个自己的mapping，决定了数据类型，建立倒排索引的行为，进行搜索的行为。</p>
<h3 id="5-11-mapping的核心数据类型以及dynamic-mapping"><a href="#5-11-mapping的核心数据类型以及dynamic-mapping" class="headerlink" title="5.11 mapping的核心数据类型以及dynamic mapping"></a>5.11 mapping的核心数据类型以及dynamic mapping</h3><h4 id="核心的数据类型"><a href="#核心的数据类型" class="headerlink" title="核心的数据类型"></a>核心的数据类型</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">string
byte，short，integer，long
float，double
boolean
date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="dynamic-mapping类型推测"><a href="#dynamic-mapping类型推测" class="headerlink" title="dynamic mapping类型推测"></a>dynamic mapping类型推测</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">true or false	 --&gt;	boolean
123		         --&gt;	long
123.01		     --&gt;	double
2020-01-01	     --&gt;	date
&quot;hello world es&quot; --&gt;	string&#x2F;text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-12-手动建立和修改mapping以及定制string类型数据是否分词"><a href="#5-12-手动建立和修改mapping以及定制string类型数据是否分词" class="headerlink" title="5.12 手动建立和修改mapping以及定制string类型数据是否分词"></a>5.12 手动建立和修改mapping以及定制string类型数据是否分词</h3><h4 id="如何建立索引"><a href="#如何建立索引" class="headerlink" title="如何建立索引"></a>如何建立索引</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">analyzed      ------ 分词类型
not_analyzed  ------ 不分词
no            ------ 不分词同时不能被搜索<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>只能创建index时手动建立mapping，或者新增field mapping，但是不能update field mapping</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;website
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;author_id&quot;: &#123;
        &quot;type&quot;: &quot;long&quot;
      &#125;,
      &quot;title&quot;: &#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;english&quot;
      &#125;,
      &quot;content&quot;: &#123;
        &quot;type&quot;: &quot;text&quot;
      &#125;,
      &quot;post_date&quot;: &#123;
        &quot;type&quot;: &quot;date&quot;
      &#125;,
      &quot;publisher_id&quot;: &#123;
        &quot;type&quot;: &quot;keyword&quot;
      &#125;,
      &quot;is_del&quot;: &#123;
        &quot;type&quot;:&quot;boolean&quot;,
        &quot;index&quot;:false
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>“index”:false 表示不加入索引<br>“type”: “keyword” 表示不分词，在7.x版本后not_analyzed已经被取消掉了</p>
</blockquote>
<p>新增filed mapping</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;website&#x2F;_mapping
&#123;
  &quot;properties&quot;:&#123;
    
    &quot;new_filed&quot;:&#123;
      &quot;type&quot;:&quot;text&quot;,
      &quot;index&quot;:false
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-13-mapping复杂数据类型以及object类型数据底层结构"><a href="#5-13-mapping复杂数据类型以及object类型数据底层结构" class="headerlink" title="5.13 mapping复杂数据类型以及object类型数据底层结构"></a>5.13 mapping复杂数据类型以及object类型数据底层结构</h3><h4 id="multivalue-field"><a href="#multivalue-field" class="headerlink" title="multivalue field"></a>multivalue field</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">&#123; &quot;tags&quot;: [ &quot;tag1&quot;, &quot;tag2&quot; ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>建立索引时与string是一样的，数据类型不能混</p>
<h4 id="empty-field"><a href="#empty-field" class="headerlink" title="empty field"></a>empty field</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">null，[]，[null]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="object-field"><a href="#object-field" class="headerlink" title="object field"></a>object field</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;company&#x2F;employee&#x2F;1
&#123;
  &quot;address&quot;: &#123;
    &quot;country&quot;: &quot;china&quot;,
    &quot;province&quot;: &quot;guangdong&quot;,
    &quot;city&quot;: &quot;guangzhou&quot;
  &#125;,
  &quot;name&quot;: &quot;jack&quot;,
  &quot;age&quot;: 27,
  &quot;join_date&quot;: &quot;2020-01-01&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应这种object类型的底层数据存储示例</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&quot;authors&quot;: [
    &#123; &quot;age&quot;: 26, &quot;name&quot;: &quot;Jack White&quot;&#125;,
    &#123; &quot;age&quot;: 55, &quot;name&quot;: &quot;Tom Jones&quot;&#125;,
    &#123; &quot;age&quot;: 39, &quot;name&quot;: &quot;Kitty Smith&quot;&#125;
]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的会转换成下面这种：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&#123;
    &quot;authors.age&quot;:    [26, 55, 39],
    &quot;authors.name&quot;:   [jack, white, tom, jones, kitty, smith]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-14-search-api的基础语法介绍"><a href="#5-14-search-api的基础语法介绍" class="headerlink" title="5.14 search api的基础语法介绍"></a>5.14 search api的基础语法介绍</h3><h4 id="search-api的基本语法"><a href="#search-api的基本语法" class="headerlink" title="search api的基本语法"></a>search api的基本语法</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;search
&#123;&#125;

GET &#x2F;index1,index2&#x2F;type1,type2&#x2F;search
&#123;&#125;

GET &#x2F;_search
&#123;
  &quot;from&quot;: 0,
  &quot;size&quot;: 10
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="http协议中get是否可以带上request-body"><a href="#http协议中get是否可以带上request-body" class="headerlink" title="http协议中get是否可以带上request body"></a>http协议中get是否可以带上request body</h4><p>HTTP协议，一般不允许get请求带上request body，但是因为get更加适合描述查询数据的操作。 碰巧，很多浏览器，或者是服务器，也都支持GET+request body模式；如果遇到不支持的场景，也可以用POST /_search</p>
<h3 id="5-15-快速上机动手实战Query-DSL搜索语法"><a href="#5-15-快速上机动手实战Query-DSL搜索语法" class="headerlink" title="5.15 快速上机动手实战Query DSL搜索语法"></a>5.15 快速上机动手实战Query DSL搜索语法</h3><h4 id="示例什么是Query-DSL"><a href="#示例什么是Query-DSL" class="headerlink" title="示例什么是Query DSL"></a>示例什么是Query DSL</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match_all&quot;: &#123;&#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Query-DSL的基本语法"><a href="#Query-DSL的基本语法" class="headerlink" title="Query DSL的基本语法"></a>Query DSL的基本语法</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">&#123;
    QUERY_NAME: &#123;
        ARGUMENT: VALUE,
        ARGUMENT: VALUE,...
    &#125;
&#125;

&#123;
    QUERY_NAME: &#123;
        FIELD_NAME: &#123;
            ARGUMENT: VALUE,
            ARGUMENT: VALUE,...
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;test_index&#x2F;_search 
&#123;
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;test_field&quot;: &quot;test&quot;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="如何组合多个搜索条件"><a href="#如何组合多个搜索条件" class="headerlink" title="如何组合多个搜索条件"></a>如何组合多个搜索条件</h4><p>初始数据：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;website&#x2F;_doc&#x2F;1
&#123;
  
  &quot;title&quot;: &quot;my elasticsearch article&quot;,
  &quot;content&quot;: &quot;es is very bad&quot;,
  &quot;author_id&quot;: 110
&#125;

PUT &#x2F;website&#x2F;_doc&#x2F;2
&#123;
  
  &quot;title&quot;: &quot;my elasticsearch article&quot;,
  &quot;content&quot;: &quot;es is very good&quot;,
  &quot;author_id&quot;: 111
&#125;

PUT &#x2F;website&#x2F;_doc&#x2F;3
&#123;
  
  &quot;title&quot;: &quot;my elasticsearch article&quot;,
  &quot;content&quot;: &quot;es is just so so&quot;,
  &quot;author_id&quot;: 112
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>title必须包含elasticsearch，content可以包含elasticsearch也可以不包含，author_id必须不为111</li>
</ol>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;website&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;bool&quot;: &#123;
      &quot;must&quot;: [
        &#123;
          &quot;match&quot;: &#123;
            &quot;title&quot;: &quot;elasticsearch&quot;
          &#125;
        &#125;
      ],
      &quot;should&quot;: [
        &#123;
          &quot;match&quot;: &#123;
            &quot;content&quot;: &quot;elasticsearch&quot;
          &#125;
        &#125;
      ],
      &quot;must_not&quot;: [
        &#123;
          &quot;match&quot;: &#123;
            &quot;author_id&quot;: 111
          &#125;
        &#125;
      ]
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例2</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;website&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;bool&quot;: &#123;
      &quot;must&quot;: &#123;
        &quot;match&quot;: &#123;
          &quot;name&quot;: &quot;tom&quot;
        &#125;
      &#125;,
      &quot;should&quot;: [
        &#123;
          &quot;match&quot;: &#123;
            &quot;hired&quot;: true
          &#125;
        &#125;,
        &#123;
          &quot;bool&quot;: &#123;
            &quot;must&quot;: &#123;
              &quot;match&quot;: &#123;
                &quot;personality&quot;: &quot;good&quot;
              &#125;
            &#125;,
            &quot;must_not&quot;: &#123;
              &quot;match&quot;: &#123;
                &quot;rude&quot;: true
              &#125;
            &#125;
          &#125;
        &#125;
      ],
      &quot;minimum_should_match&quot;: 1
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>should 相当于or<br>bool 相当于（）<br>must 相当于and<br>must_not 就是不等于</p>
</blockquote>
<h3 id="5-16-filter与query深入对比解密：相关度，性能"><a href="#5-16-filter与query深入对比解密：相关度，性能" class="headerlink" title="5.16 filter与query深入对比解密：相关度，性能"></a>5.16 filter与query深入对比解密：相关度，性能</h3><h4 id="filter与query示例"><a href="#filter与query示例" class="headerlink" title="filter与query示例"></a>filter与query示例</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;company&#x2F;_doc&#x2F;1
&#123;
  &quot;join_date&quot;: &quot;2016-01-01&quot;,
  &quot;age&quot;:33,
  &quot;name&quot;:&quot;tom cat&quot;
&#125;

PUT &#x2F;company&#x2F;_doc&#x2F;2
&#123;
  &quot;join_date&quot;: &quot;2016-01-01&quot;,
  &quot;age&quot;:29,
  &quot;name&quot;:&quot;jerry mouse&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>搜索请求：年龄必须大于等于30，同时join_date必须是2016-01-01</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;company&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;bool&quot;: &#123;
      &quot;must&quot;: [
        &#123;
          &quot;match&quot;: &#123;
            &quot;join_date&quot;: &quot;2016-01-01&quot;
          &#125;
        &#125;
      ],
      &quot;filter&quot;: &#123;
        &quot;range&quot;: &#123;
          &quot;age&quot;: &#123;
            &quot;gte&quot;: 30
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="filter与query对比大解密"><a href="#filter与query对比大解密" class="headerlink" title="filter与query对比大解密"></a>filter与query对比大解密</h4><ul>
<li>filter，仅仅只是按照搜索条件过滤出需要的数据而已，不计算任何相关度分数，对相关度没有任何影响；</li>
<li>query，会去计算每个document相对于搜索条件的相关度，并按照相关度进行排序；</li>
</ul>
<p>一般来说，如果你是在进行搜索，需要将最匹配搜索条件的数据先返回，那么用query；如果只是要根据一些条件筛选出一部分数据，不关注其排序，那么用filter；除非是你的这些搜索条件，你希望越符合这些搜索条件的document越排在前面返回，那么这些搜索条件要放在query中；如果你不希望一些搜索条件来影响你的document排序，那么就放在filter中即可。</p>
<h4 id="filter与query性能"><a href="#filter与query性能" class="headerlink" title="filter与query性能"></a>filter与query性能</h4><ul>
<li>filter，不需要计算相关度分数，不需要按照相关度分数进行排序，同时还有内置的自动cache最常使用filter的数据</li>
<li>query，相反，要计算相关度分数，按照分数进行排序，而且无法cache结果</li>
<li>bool，must，must_not，should，filter：每个子查询都会计算一个document针对它的相关度分数，然后bool综合所有分数，合并为一个分数，当然filter是不会计算分数的</li>
</ul>
<h3 id="5-17-常用的各种query搜索语法"><a href="#5-17-常用的各种query搜索语法" class="headerlink" title="5.17 常用的各种query搜索语法"></a>5.17 常用的各种query搜索语法</h3><h4 id="match-all"><a href="#match-all" class="headerlink" title="match all"></a>match all</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match_all&quot;: &#123;&#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_search
&#123;
    &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;my elasticsearch article&quot; &#125;&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="multi-match"><a href="#multi-match" class="headerlink" title="multi match"></a>multi match</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;test_index&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;multi_match&quot;: &#123;
      &quot;query&quot;: &quot;test&quot;,
      &quot;fields&quot;: [&quot;test_field&quot;, &quot;test_field1&quot;]
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="range-query"><a href="#range-query" class="headerlink" title="range query"></a>range query</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;company&#x2F;_search 
&#123;
  &quot;query&quot;: &#123;
    &quot;range&quot;: &#123;
      &quot;age&quot;: &#123;
        &quot;gte&quot;: 30
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="term-query"><a href="#term-query" class="headerlink" title="term query"></a>term query</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;test_index&#x2F;_search 
&#123;
  &quot;query&quot;: &#123;
    &quot;term&quot;: &#123;
      &quot;test_field&quot;: &quot;test hello&quot;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="terms-query"><a href="#terms-query" class="headerlink" title="terms query"></a>terms query</h4><p>对tag指定多个分组词</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_search
&#123;
    &quot;query&quot;: &#123; &quot;terms&quot;: &#123; &quot;tag&quot;: [ &quot;search&quot;, &quot;full_text&quot;, &quot;nosql&quot; ] &#125;&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-18-如何定位不合法的搜索以及其原因"><a href="#5-18-如何定位不合法的搜索以及其原因" class="headerlink" title="5.18 如何定位不合法的搜索以及其原因"></a>5.18 如何定位不合法的搜索以及其原因</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;company&#x2F;_validate&#x2F;query?explain
&#123;
  &quot;query&quot;: &#123;
    &quot;match&quot;: &#123;
      &quot;name&quot;: &quot;cat&quot;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一般用在那种特别复杂庞大的搜索下，比如一下子写了上百行的搜索，这个时候可以先用validate api去验证一下，搜索是否合法</p>
<h3 id="5-19-如何定制搜索结果的排序规则"><a href="#5-19-如何定制搜索结果的排序规则" class="headerlink" title="5.19 如何定制搜索结果的排序规则"></a>5.19 如何定制搜索结果的排序规则</h3><h4 id="默认排序规则"><a href="#默认排序规则" class="headerlink" title="默认排序规则"></a>默认排序规则</h4><p>默认情况下，是按照_score降序排序的；然而，某些情况下，可能没有有用的_score，比如说filter</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;bool&quot;: &#123;
      &quot;filter&quot;: &#123;
        &quot;term&quot;: &#123;
          &quot;name&quot;: &quot;cat&quot;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，也可以是constant_score</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;constant_score&quot;: &#123;
      &quot;filter&quot;: &#123;
        &quot;term&quot;: &#123;
          &quot;author_id&quot;: 1
        &#125;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="定制排序规则"><a href="#定制排序规则" class="headerlink" title="定制排序规则"></a>定制排序规则</h4><p>使用sort来定制排序规则</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;company&#x2F;_search 
&#123;
  &quot;query&quot;: &#123;
    &quot;constant_score&quot;: &#123;
      &quot;filter&quot;: &#123;
        &quot;range&quot;: &#123;
          &quot;age&quot;: &#123;
            &quot;gte&quot;: 25
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;,
  &quot;sort&quot;: [
    &#123;
      &quot;join_date&quot;: &#123;
        &quot;order&quot;: &quot;asc&quot;
      &#125;
    &#125;
  ]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-20-如何将一个field索引两次来解决字符串排序问题"><a href="#5-20-如何将一个field索引两次来解决字符串排序问题" class="headerlink" title="5.20 如何将一个field索引两次来解决字符串排序问题"></a>5.20 如何将一个field索引两次来解决字符串排序问题</h3><p>如果对一个string field进行排序，结果往往不准确，因为分词后是多个单词，再排序就不是我们想要的结果了</p>
<p>通常解决方案是，将一个string field建立两次索引，一个分词，用来进行搜索；一个不分词，用来进行排序</p>
<p>示例：先创建索引</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;website 
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;title&quot;: &#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;fields&quot;: &#123;
          &quot;raw&quot;: &#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;,
        &quot;fielddata&quot;: true
      &#125;,
      &quot;content&quot;: &#123;
        &quot;type&quot;: &quot;text&quot;
      &#125;,
      &quot;post_date&quot;: &#123;
        &quot;type&quot;: &quot;date&quot;
      &#125;,
      &quot;author_id&quot;: &#123;
        &quot;type&quot;: &quot;long&quot;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>设置正排索引 “fielddata”: true</p>
</blockquote>
<p>添加初始数据</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;website&#x2F;_doc&#x2F;1
&#123;
  &quot;title&quot;: &quot;first article&quot;,
  &quot;content&quot;: &quot;this is my first article&quot;,
  &quot;post_date&quot;: &quot;2017-01-01&quot;,
  &quot;author_id&quot;: 110
&#125;

PUT &#x2F;website&#x2F;_doc&#x2F;2
&#123;
  &quot;title&quot;: &quot;second article&quot;,
  &quot;content&quot;: &quot;this is my second article&quot;,
  &quot;post_date&quot;: &quot;2018-01-01&quot;,
  &quot;author_id&quot;: 111
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行查询</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;website&#x2F;_search
&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;: &#123;&#125;
  &#125;,
  &quot;sort&quot;: [
    &#123;
      &quot;title.raw&quot;: &#123;
        &quot;order&quot;: &quot;desc&quot;
      &#125;
    &#125;
  ]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-21-相关度评分TF-amp-IDF算法"><a href="#5-21-相关度评分TF-amp-IDF算法" class="headerlink" title="5.21 相关度评分TF&amp;IDF算法"></a>5.21 相关度评分TF&amp;IDF算法</h3><h4 id="TF-amp-IDF算法介绍"><a href="#TF-amp-IDF算法介绍" class="headerlink" title="TF&amp;IDF算法介绍"></a>TF&amp;IDF算法介绍</h4><ul>
<li>relevance score算法，简单来说，就是计算出，一个索引中的文本，与搜索文本，他们之间的关联匹配程度；</li>
<li>Elasticsearch使用的是 term frequency/inverse document frequency算法，简称为TF/IDF算法；</li>
<li>Term frequency：搜索文本中的各个词条在field文本中出现了多少次，出现次数越多，就越相关；</li>
<li>Inverse document frequency：搜索文本中的各个词条在整个索引的所有文档中出现了多少次，出现的次数越多，就越不相关；</li>
</ul>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">举个例子：
    搜索请求：hello world
    
    doc1：hello, today is very good
    doc2：hi world, how are you
    
    比如说，在index中有1万条document，hello这个单词在所有的document中，一共出现了1000次；world这个单词在所有的document中，一共出现了100次；那么doc2的相关度越高<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>Field-length norm：field内容长度，越长，相关度越弱</li>
</ul>
<h3 id="5-22-内核级知识点之doc-value初步探秘"><a href="#5-22-内核级知识点之doc-value初步探秘" class="headerlink" title="5.22 内核级知识点之doc value初步探秘"></a>5.22 内核级知识点之doc value初步探秘</h3><p>搜索的时候，要依靠倒排索引；排序的时候，需要依靠正排索引，看到每个document的每个field，然后进行排序，所谓的正排索引，其实就是doc values； </p>
<p>在建立索引的时候，一方面会建立倒排索引，以供搜索用；一方面会建立正排索引，也就是doc values，以供排序，聚合，过滤等操作使用；</p>
<p>doc values是被保存在磁盘上的，此时如果内存足够，os会自动将其缓存在内存中，性能还是很高的；如果内存不足够，os会将其写入磁盘上；</p>
<p>倒排索引类似如下（对每个字段进行操作）：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">doc1的content字段内容: hello world you and me
doc2的content字段内容: hi, world, how are you<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对上面的内容进行分词，拆分为一个个单词(term)，建立类似如下的字典目录</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">|term|Posting List（倒排列表）|
|:--:|:--|
|world|[doc1,doc2]|
|hello|doc1|
|hi|doc2|
|...|....|<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>Posting List（倒排列表）里面是文档的id</p>
</blockquote>
<p>这样在搜索时根据term的索引（类似MySQL的索引）去找到符合的term进而找到对应的文档信息；</p>
<p>可以这样理解倒排索引：通过单词找到对应的倒排列表，根据倒排列表中的倒排项进而可以找到文档记录；过程类型如下图：<br><img src="https://media-vchar.oss-cn-hangzhou.aliyuncs.com/image/blog/dsc/es-005.png"></p>
<p>正排索引类似如下（对整个文档进行操作）：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">doc1内容: &#123; &quot;name&quot;: &quot;jack&quot;, &quot;age&quot;: 27 &#125;
doc2内容: &#123; &quot;name&quot;: &quot;tom&quot;, &quot;age&quot;: 30 &#125;

document	name		age
doc1		jack		27
doc2		tom		    30	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-23-分布式搜索引擎内核解密之query-phase"><a href="#5-23-分布式搜索引擎内核解密之query-phase" class="headerlink" title="5.23 分布式搜索引擎内核解密之query phase"></a>5.23 分布式搜索引擎内核解密之query phase</h3><h4 id="query-phase"><a href="#query-phase" class="headerlink" title="query phase"></a>query phase</h4><ol>
<li>搜索请求发送到某一个coordinate node，构构建一个priority queue，长度以paging操作from和size为准，默认为10</li>
<li>coordinate node将请求转发到所有shard，每个shard本地搜索，并构建一个本地的priority queue</li>
<li>各个shard将自己的priority queue返回给coordinate node，并构建一个全局的priority queue</li>
</ol>
<p><img src="https://media-vchar.oss-cn-hangzhou.aliyuncs.com/image/blog/dsc/es-006.png"></p>
<h4 id="replica-shard如何提升搜索吞吐量"><a href="#replica-shard如何提升搜索吞吐量" class="headerlink" title="replica shard如何提升搜索吞吐量"></a>replica shard如何提升搜索吞吐量</h4><p>一次请求要打到所有shard的一个replica/primary上去，如果每个shard都有多个replica，那么同时并发过来的搜索请求可以同时打到其他的replica上去</p>
<h3 id="5-24-分布式搜索引擎内核解密之fetch-phase"><a href="#5-24-分布式搜索引擎内核解密之fetch-phase" class="headerlink" title="5.24 分布式搜索引擎内核解密之fetch phase"></a>5.24 分布式搜索引擎内核解密之fetch phase</h3><p>fetch phase工作流程:</p>
<ol>
<li>coordinate node构建完priority queue之后，就发送mget请求去所有shard上获取对应的document</li>
<li>各个shard将document返回给coordinate node</li>
<li>coordinate node将合并后的document结果返回给client客户端</li>
</ol>
<p>一般搜索，如果不加from和size，就默认搜索前10条，按照_score排序</p>
<p><img src="https://media-vchar.oss-cn-hangzhou.aliyuncs.com/image/blog/dsc/es-007.png"></p>
<h3 id="5-25-搜索相关参数梳理以及bouncing-results问题解决方案"><a href="#5-25-搜索相关参数梳理以及bouncing-results问题解决方案" class="headerlink" title="5.25 搜索相关参数梳理以及bouncing results问题解决方案"></a>5.25 搜索相关参数梳理以及bouncing results问题解决方案</h3><h4 id="preference"><a href="#preference" class="headerlink" title="preference"></a>preference</h4><p>决定了哪些shard会被用来执行搜索操作</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">_primary, _primary_first, _local, _only_node:xyz, _prefer_node:xyz, _shards:2,3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>bouncing results问题，两个document排序，field值相同；不同的shard上，可能排序不同；每次请求轮询打到不同的replica shard上；每次页面上看到的搜索结果的排序都不一样。这就是bouncing result，也就是跳跃的结果。</p>
<p>搜索的时候，是轮询将搜索请求发送到每一个replica shard（primary shard），但是在不同的shard上，可能document的排序不同</p>
<p>解决方案就是将preference设置为一个字符串，比如说user_id，让每个user每次搜索的时候，都使用同一个replica shard去执行，就不会看到bouncing results了</p>
<h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><p>主要就是限定在一定时间内，将部分获取到的数据直接返回，避免查询耗时过长</p>
<h4 id="routing"><a href="#routing" class="headerlink" title="routing"></a>routing</h4><p>document文档路由，_id路由，routing=user_id，这样的话可以让同一个user对应的数据到一个shard上去</p>
<h4 id="search-type"><a href="#search-type" class="headerlink" title="search_type"></a>search_type</h4><ul>
<li>default：query_then_fetch</li>
<li>dfs_query_then_fetch，可以提升relevance sort精准度</li>
</ul>
<h3 id="5-26-基于scroll技术滚动搜索大量数据"><a href="#5-26-基于scroll技术滚动搜索大量数据" class="headerlink" title="5.26 基于scroll技术滚动搜索大量数据"></a>5.26 基于scroll技术滚动搜索大量数据</h3><p>如果一次性要查出来10万条数据，那么性能会很差，此时一般会采取用scroll滚动查询，一批一批的查，直到所有数据都查询完处理完。</p>
<p>使用scroll滚动搜索，可以先搜索一批数据，然后下次再搜索一批数据，以此类推，直到搜索出全部的数据来</p>
<p>scroll搜索会在第一次搜索的时候，保存一个当时的视图快照，之后只会基于该旧的视图快照提供数据搜索，如果这个期间数据变更，是不会让用户看到的</p>
<p>采用基于_doc进行排序的方式，性能较高</p>
<p>每次发送scroll请求，我们还需要指定一个scroll参数，指定一个时间窗口，每次搜索请求只要在这个时间窗口内能完成就可以了；</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;website&#x2F;_search?scroll&#x3D;1m
&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;: &#123;&#125;
  &#125;,
  &quot;sort&quot;: [ &quot;_doc&quot; ],
  &quot;size&quot;: 3
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>获得的结果会有一个scroll_id，下一次再发送scroll请求的时候，必须带上这个scroll_id</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;_search&#x2F;scroll
&#123;
    &quot;scroll&quot;: &quot;1m&quot;, 
    &quot;scroll_id&quot; : &quot;FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFHg3bnJvM01CYXBadGRjZ1FELWNqAAAAAAAADY8WdXVKQzR3TzVSMEtialVYM1gxbWkzZw&#x3D;&#x3D;&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="六、索引管理"><a href="#六、索引管理" class="headerlink" title="六、索引管理"></a>六、索引管理</h2><h3 id="6-1-索引的创建、修改、删除"><a href="#6-1-索引的创建、修改、删除" class="headerlink" title="6.1 索引的创建、修改、删除"></a>6.1 索引的创建、修改、删除</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>指定分片信息、mapping信息</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo
&#123;
  &quot;settings&quot;: &#123;
    &quot;number_of_shards&quot;: 1,
    &quot;number_of_replicas&quot;: 0
  &#125;,
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;name&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用默认的配置</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_pretty?pretty<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo&#x2F;_settings
&#123;
  &quot;number_of_replicas&quot;: 1
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">DELETE &#x2F;index_demo
DELETE &#x2F;index_1,index_2
DELETE &#x2F;index_demo*
DELETE &#x2F;_all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="6-2-修改分词器以及定制自己的分词器"><a href="#6-2-修改分词器以及定制自己的分词器" class="headerlink" title="6.2 修改分词器以及定制自己的分词器"></a>6.2 修改分词器以及定制自己的分词器</h3><h4 id="默认的分词器standard"><a href="#默认的分词器standard" class="headerlink" title="默认的分词器standard"></a>默认的分词器standard</h4><ul>
<li>standard tokenizer：以单词边界进行切分</li>
<li>standard token filter：什么都不做</li>
<li>lowercase token filter：将所有字母转换为小写</li>
<li>stop token filer（默认被禁用）：移除停用词，比如a the it等等</li>
</ul>
<h4 id="修改分词器的设置"><a href="#修改分词器的设置" class="headerlink" title="修改分词器的设置"></a>修改分词器的设置</h4><ul>
<li>启用english停用词token filter（创建索引的时候才可以）</li>
</ul>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo
&#123;
  &quot;settings&quot;: &#123;
    &quot;number_of_shards&quot;: 1,
    &quot;number_of_replicas&quot;: 0,
    &quot;analysis&quot;: &#123;
      &quot;analyzer&quot;: &#123;
        &quot;es_std&quot;:&#123;
          &quot;type&quot;: &quot;standard&quot;,
          &quot;stopwords&quot;: &quot;_english_&quot;
        &#125;
      &#125;
    &#125;
  &#125;,
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;name&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试定制的分词器的效果：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># 使用定制的
GET &#x2F;index_demo&#x2F;_analyze
&#123;
  &quot;analyzer&quot;: &quot;es_std&quot;,
  &quot;text&quot;: &quot;a dog is in the house&quot;
&#125;

# 使用默认的
GET &#x2F;index_demo&#x2F;_analyze
&#123;
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;:&quot;a dog is in the house&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="定制分词器"><a href="#定制分词器" class="headerlink" title="定制分词器"></a>定制分词器</h4><p>将<code>&amp;</code>转换为and，<code>a 、the</code>不做处理，将html标签过滤掉，将字符转为小写的</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo
&#123;
  &quot;settings&quot;: &#123;
    &quot;analysis&quot;: &#123;
      &quot;char_filter&quot;: &#123;
        &quot;&amp;_to_and&quot;: &#123;
          &quot;type&quot;: &quot;mapping&quot;,
          &quot;mappings&quot;: [&quot;&amp;&#x3D;&gt; and&quot;]
        &#125;
      &#125;,
      &quot;filter&quot;: &#123;
        &quot;my_stopwords&quot;:&#123;
          &quot;type&quot;: &quot;stop&quot;,
          &quot;stopwords&quot;: [&quot;the&quot;, &quot;a&quot;]
        &#125;
      &#125;,
      &quot;analyzer&quot;: &#123;
        &quot;my_analyzer&quot;:&#123;
          &quot;type&quot;:&quot;custom&quot;,
          &quot;char_filter&quot;: [&quot;html_strip&quot;, &quot;&amp;_to_and&quot;],
          &quot;tokenizer&quot;:&quot;standard&quot;,
          &quot;filter&quot;:[&quot;lowercase&quot;,&quot;my_stopwords&quot;]
        &#125;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试定制的分词器</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;index_demo&#x2F;_analyze
&#123;
  &quot;text&quot;: &quot;tom&amp;jerry are a friend in the house, &lt;a&gt;, HAHA!!&quot;,
  &quot;analyzer&quot;: &quot;my_analyzer&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="6-3-深入探秘type底层数据结构"><a href="#6-3-深入探秘type底层数据结构" class="headerlink" title="6.3 深入探秘type底层数据结构"></a>6.3 深入探秘type底层数据结构</h3><p>type是一个index中用来区分类似的数据的，类似的数据，但是可能有不同的fields，而且有不同的属性来控制索引建立、分词器； field的value，在底层的lucene中建立索引的时候，全部是opaque bytes类型，不区分类型的； lucene是没有type的概念的，在document中，实际上将type作为一个document的field来存储，即_type，es通过_type来进行type的过滤和筛选； 一个index中的多个type，实际上是放在一起存储的，因此一个index下，不能有多个type重名，因为那样是无法处理的； 在es7中一个index只能有一个type，默认为_doc，不推荐去自定义了。</p>
<h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>设置的mappings如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&#123;
   &quot;ecommerce&quot;: &#123;
      &quot;mappings&quot;: &#123;
        &quot;_type&quot;: &#123;
          &quot;type&quot;: &quot;string&quot;,
          &quot;index&quot;: &quot;not_analyzed&quot;
        &#125;,
        &quot;name&quot;: &#123;
          &quot;type&quot;: &quot;string&quot;
        &#125;
        &quot;price&quot;: &#123;
          &quot;type&quot;: &quot;double&quot;
        &#125;
        &quot;service_period&quot;: &#123;
          &quot;type&quot;: &quot;string&quot;
        &#125;
        &quot;eat_period&quot;: &#123;
          &quot;type&quot;: &quot;string&quot;
        &#125;
      &#125;
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设有如下2条数据存入</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&#123;
  &quot;name&quot;: &quot;geli kongtiao&quot;,
  &quot;price&quot;: 1999.0,
  &quot;service_period&quot;: &quot;one year&quot;
&#125;

&#123;
  &quot;name&quot;: &quot;aozhou dalongxia&quot;,
  &quot;price&quot;: 199.0,
  &quot;eat_period&quot;: &quot;one week&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在底层的存储是这样子的</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">&#123;
  &quot;_type&quot;: &quot;elactronic_goods&quot;,
  &quot;name&quot;: &quot;geli kongtiao&quot;,
  &quot;price&quot;: 1999.0,
  &quot;service_period&quot;: &quot;one year&quot;,
  &quot;eat_period&quot;: &quot;&quot;
&#125;

&#123;
  &quot;_type&quot;: &quot;fresh_goods&quot;,
  &quot;name&quot;: &quot;aozhou dalongxia&quot;,
  &quot;price&quot;: 199.0,
  &quot;service_period&quot;: &quot;&quot;,
  &quot;eat_period&quot;: &quot;one week&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果存入数据没有某个filed时，将会存入一个空值；假如说，将两个type的field完全不同，放在一个index下，那么就每条数据都至少有一半的field在底层的lucene中是空值，会有严重的性能问题；因此在es7中一个index只能有一个type，默认为_doc，不推荐去自定义了。</p>
<h3 id="6-4-mapping-root-object剖析"><a href="#6-4-mapping-root-object剖析" class="headerlink" title="6.4 mapping root object剖析"></a>6.4 mapping root object剖析</h3><h4 id="root-object"><a href="#root-object" class="headerlink" title="root object"></a>root object</h4><p>就是某个type对应的mapping json，包括了properties，metadata（_id，_source，_type），settings（analyzer），其他settings（比如include_in_all）</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h4><p>type，index，analyzer</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo&#x2F;_mapping
&#123;
  &quot;properties&quot;: &#123;
    &quot;title&quot;: &#123;
      &quot;type&quot;: &quot;text&quot;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="source"><a href="#source" class="headerlink" title="_source"></a>_source</h4><p>优点：</p>
<ol>
<li>查询的时候，直接可以拿到完整的document，不需要先拿document id，再发送一次请求拿document</li>
<li>partial update基于_source实现</li>
<li>reindex时，直接基于_source实现，不需要从数据库（或者其他外部存储）查询数据再修改</li>
<li>可以基于_source定制返回field</li>
<li>debug query更容易，因为可以直接看到_source</li>
</ol>
<p>如果不需要上述好处，可以禁用_source；但是不建议这么做<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-source-field.html#disable-source-field">官方说明</a></p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo
&#123;
  &quot;mappings&quot;: &#123;
    &quot;_source&quot;: &#123;&quot;enabled&quot;: false&#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="标识性metadata"><a href="#标识性metadata" class="headerlink" title="标识性metadata"></a>标识性metadata</h4><p>_index，_type，_id</p>
<h3 id="6-5-定制化自己的dynamic-mapping"><a href="#6-5-定制化自己的dynamic-mapping" class="headerlink" title="6.5 定制化自己的dynamic mapping"></a>6.5 定制化自己的dynamic mapping</h3><h4 id="定制dynamic策略"><a href="#定制dynamic策略" class="headerlink" title="定制dynamic策略"></a>定制dynamic策略</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">true：遇到陌生字段，就进行dynamic mapping
false：遇到陌生字段，就忽略
strict：遇到陌生字段，就报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>示例：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo
&#123;
  &quot;mappings&quot;: &#123;
    &quot;dynamic&quot;:&quot;strict&quot;,
    &quot;properties&quot;: &#123;
      &quot;title&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;
      &#125;,
      &quot;address&quot;:&#123;
        &quot;type&quot;: &quot;object&quot;,
        &quot;dynamic&quot;: true
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试数据添加是否可以成功</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo&#x2F;_doc&#x2F;1
&#123;
  &quot;title&quot;:&quot;this is firestone&quot;,
  &quot;content&quot;:&quot;this is content&quot;,
  &quot;address&quot;:&#123;
    &quot;province&quot;:&quot;北京&quot;,
    &quot;city&quot;:&quot;北京&quot;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于做了现在，因此上面这个会添加失败</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo&#x2F;_doc&#x2F;1
&#123;
  &quot;title&quot;:&quot;this is firestone&quot;,
  &quot;address&quot;:&#123;
    &quot;province&quot;:&quot;北京&quot;,
    &quot;city&quot;:&quot;北京&quot;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="定制dynamic-mapping策略"><a href="#定制dynamic-mapping策略" class="headerlink" title="定制dynamic mapping策略"></a>定制dynamic mapping策略</h4><p>默认会按照一定格式识别date，比如yyyy-MM-dd。但是如果某个field先过来一个2017-01-01的值，就会被自动dynamic mapping成date，<br>后面如果再来一个”hello world”之类的值，就会报错。可以手动关闭某个type的date_detection，如果有需要，自己手动指定某个field为date类型。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo&#x2F;_mapping
&#123;
    &quot;date_detection&quot;: false
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="定制自己的dynamic-mapping-template"><a href="#定制自己的dynamic-mapping-template" class="headerlink" title="定制自己的dynamic mapping template"></a>定制自己的dynamic mapping template</h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo
&#123;
  &quot;mappings&quot;: &#123;
    &quot;dynamic_templates&quot;: [
      &#123;
        &quot;en&quot;: &#123;
          &quot;match&quot;: &quot;*_en&quot;,
          &quot;match_mapping_type&quot;: &quot;string&quot;,
          &quot;mapping&quot;: &#123;
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;english&quot;
          &#125;
        &#125;
      &#125;
    ]
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT index_demo&#x2F;_doc&#x2F;1
&#123;
 &quot;title&quot;:&quot;this is my first article&quot;
&#125;

PUT index_demo&#x2F;_doc&#x2F;2
&#123;
 &quot;title_en&quot;:&quot;this is my first article&quot;
&#125;

GET &#x2F;index_demo&#x2F;_search
&#123;
  &quot;query&quot;:&#123;
    &quot;match&quot;: &#123;
      &quot;title&quot;: &quot;is&quot;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>title没有匹配到任何的dynamic模板，默认就是standard分词器，不会过滤停用词，is会进入倒排索引，用is来搜索是可以搜索到的；title_en匹配到了dynamic模板，就是english分词器，会过滤停用词，is这种停用词就会被过滤掉，用is来搜索就搜索不到了。</p>
<h3 id="6-6-基于scroll-bulk-索引别名实现零停机重建索引"><a href="#6-6-基于scroll-bulk-索引别名实现零停机重建索引" class="headerlink" title="6.6 基于scroll+bulk+索引别名实现零停机重建索引"></a>6.6 基于scroll+bulk+索引别名实现零停机重建索引</h3><h4 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h4><p>一个field的设置是不能被修改的，如果要修改一个Field，那么应该重新按照新的mapping，建立一个index，然后将数据批量查询出来，重新用bulk api写入index中；批量查询的时候，建议采用scroll api，并且采用多线程并发的方式来reindex数据，每次scroll就查询指定日期的一段数据，交给一个线程即可；</p>
<p>举个例子：</p>
<p>（1）一开始，依靠dynamic mapping，插入数据，但是不小心有些数据是2017-01-01这种日期格式的，所以title这种field被自动映射为了date类型，实际上它应该是string类型的。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo&#x2F;_doc&#x2F;1
&#123;
  &quot;title&quot;:&quot;2020-01-01&quot;
&#125;

PUT &#x2F;index_demo&#x2F;_doc&#x2F;2
&#123;
  &quot;title&quot;:&quot;2020-01-02&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（2）当后期向索引中加入string类型的title值的时候，就会报错。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo&#x2F;_doc&#x2F;3
&#123;
  &quot;title&quot;:&quot;es 入门&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>（3）如果此时想修改title的类型，是不可能的</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo&#x2F;_mapping
&#123;
  &quot;properties&quot;:&#123;
    &quot;title&quot;:&#123;
      &quot;type&quot;:&quot;text&quot;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（4）此时，唯一的办法，就是进行reindex，也就是说，重新建立一个索引，将旧索引的数据查询出来，再导入新索引</p>
<p>（5）如果旧索引的名字是old_index，新索引的名字是new_index，终端java应用，已经在使用old_index在操作了，难道还要去停止java应用，修改使用的index为new_index，才重新启动java应用吗？这个过程中，就会导致java应用停机，可用性降低</p>
<p>（6）所以说，给java应用一个别名，这个别名是指向旧索引的，java应用先用着，java应用先用goods_index alias来操作，此时实际指向的是旧的my_index</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo&#x2F;_alias&#x2F;goods_index<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>（7）新建一个index，调整其title的类型为string</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">PUT &#x2F;index_demo_new
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;title&quot;:&#123;
        &quot;type&quot;:&quot;text&quot;
      &#125;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（8）使用scroll api将数据批量查询出来</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">GET &#x2F;index_demo&#x2F;_search?scroll&#x3D;1m
&#123;
  &quot;query&quot;: &#123;
    &quot;match_all&quot;: &#123;&#125;
  &#125;,
  &quot;sort&quot;: [&quot;_doc&quot;],
  &quot;size&quot;: 1
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（9）采用bulk api将scroll查出来的一批数据，批量写入新索引</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;_bulk
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;index_demo_new&quot;, &quot;_id&quot;:&quot;1&quot;&#125;&#125;
&#123;&quot;title&quot;:&quot;2020-01-01&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>（10）反复循环8~9，查询一批又一批的数据出来，采取bulk api将每一批数据批量写入新索引</p>
<p>（11）将goods_index alias切换到my_index_new上去，java应用会直接通过index别名使用新的索引中的数据，java应用程序不需要停机，零提交，高可用</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">POST &#x2F;_aliases
&#123;
  &quot;actions&quot;: [
    &#123;
      &quot;remove&quot;: &#123;
        &quot;index&quot;: &quot;index_demo&quot;,
        &quot;alias&quot;: &quot;goods_index&quot;
      &#125;
    &#125;,
    &#123;
      &quot;add&quot;: &#123;
        &quot;index&quot;: &quot;index_demo_new&quot;,
        &quot;alias&quot;: &quot;goods_index&quot;
      &#125;
    &#125;
  ]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（12）直接通过goods_index别名来查询，是否ok</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__type" align="center">
                <img src="/medias/promote/wx-qr-qaxc-8.jpg" width="250px;"/>
            </div>
            <div class="reprint__notice" align="center">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright" style="color: #ff0000">
                        特别提醒：扫码关注微信订阅号'起岸星辰'，实时掌握IT业界技术资讯!
                    </i>
                </span>
                <span class="reprint-info"> 转载请保留原文中的链接!</span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



    <!--<script src="https://readmore.openwrite.cn/js/readmore.js" type="text/javascript"></script>-->
    <script src="/js/readmore.min.js" type="text/javascript"></script>
    <script>
        var articleId = 'dcs/1618405200';
        articleId = articleId.split('/')
        const btw = new BTWPlugin();
        btw.init({
            id: 'articleContent',
            blogId: 'blog.vchar.top.2021',
            articleId: articleId[1],
            name: '起岸星辰',
            qrcode: '/medias/promote/wx-qr-qaxc-8.jpg',
            keyword: '1213',
        });
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Elasticsearch/">
                                    <span class="chip bg-color">Elasticsearch</span>
                                </a>
                            
                                <a href="/tags/es/">
                                    <span class="chip bg-color">es</span>
                                </a>
                            
                                <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/">
                                    <span class="chip bg-color">分布式搜索</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/dcs/1618405201.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/30.jpg" class="responsive-img" alt="Elasticsearch7学习笔记(中)">
                        
                        <span class="card-title">Elasticsearch7学习笔记(中)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Elasticsearch是实时全文搜索和分析引擎，提供搜集、分析、存储数据三大功能；是一套开放REST和JAVA API等结构提供高效搜索功能，可扩展的分布式系统。它构建于Apache Lucene搜索引擎库之上。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-04-14
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/" class="post-category">
                                    分布式搜索
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Elasticsearch/">
                        <span class="chip bg-color">Elasticsearch</span>
                    </a>
                    
                    <a href="/tags/es/">
                        <span class="chip bg-color">es</span>
                    </a>
                    
                    <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2/">
                        <span class="chip bg-color">分布式搜索</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/mysql/1618228800.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="数据库压测工具SysBench">
                        
                        <span class="card-title">数据库压测工具SysBench</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            SysBench是一个对数据库进行压力测试的工具，它可以模拟几千个线程并发的访问数据库，包括进行各种事务提交等到数据中实现更全面的测试；实现对数据库的TPS、QPS等信息的基本了解。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-04-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-category">
                                    数据库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                        <span class="chip bg-color">数据库</span>
                    </a>
                    
                    <a href="/tags/MySQL/">
                        <span class="chip bg-color">MySQL</span>
                    </a>
                    
                    <a href="/tags/SysBench/">
                        <span class="chip bg-color">SysBench</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="https://lib.baomitu.com/aplayer/latest/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="https://lib.baomitu.com/aplayer/latest/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 10px !important;display: flex;justify-content: center;">
        <div class="copy-right">
            
                <span id="year">&copy;2020-2021</span>
            
            <a href="/about" target="_blank">Vchar Fred</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                &nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="https://beian.miit.gov.cn" target="_blank">蜀ICP备18011021号</a>
            </span>
            
        </div>
    </div>
</footer>




    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "json",
            success: function (datas) {
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_tags = data.tags.join(",");
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var index_tag = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                index_tag = data_tags.indexOf(keyword)
                                if (index_title < 0 && index_content < 0 && index_tag < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.json', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://lib.baomitu.com/materialize/1.0.0/js/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
